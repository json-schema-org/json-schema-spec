


Internet Engineering Task Force                            fge. Galiegue
Internet-Draft                                          January 12, 2013
Intended status: Informational
Expires: July 16, 2013


             JSON Schema: core definitions and terminology
                            json-schema-core

Abstract

   JSON Schema defines the media type "application/schema+json", a JSON
   based format for defining the structure of JSON data.  JSON Schema
   provides a contract for what JSON data is required for a given
   application and how to interact with it.  JSON Schema is intended to
   define validation, documentation, hyperlink navigation, and
   interaction control of JSON data.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on July 16, 2013.

Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as



Galiegue                  Expires July 16, 2013                 [Page 1]

Internet-Draft                 JSON Schema                  January 2013


   described in the Simplified BSD License.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Conventions and Terminology  . . . . . . . . . . . . . . . . .  3
   3.  Core terminology . . . . . . . . . . . . . . . . . . . . . . .  3
     3.1.  Property, item . . . . . . . . . . . . . . . . . . . . . .  3
     3.2.  JSON Schema, keywords  . . . . . . . . . . . . . . . . . .  3
     3.3.  Empty schema . . . . . . . . . . . . . . . . . . . . . . .  3
     3.4.  Root schema, subschema . . . . . . . . . . . . . . . . . .  4
     3.5.  JSON Schema primitive types  . . . . . . . . . . . . . . .  4
     3.6.  JSON value equality  . . . . . . . . . . . . . . . . . . .  5
     3.7.  Instance . . . . . . . . . . . . . . . . . . . . . . . . .  5
   4.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     4.1.  Validation . . . . . . . . . . . . . . . . . . . . . . . .  5
     4.2.  Hypermedia and linking . . . . . . . . . . . . . . . . . .  6
   5.  General considerations . . . . . . . . . . . . . . . . . . . .  6
     5.1.  Applicability to all JSON values . . . . . . . . . . . . .  6
     5.2.  Programming language independence  . . . . . . . . . . . .  6
     5.3.  JSON Schema and HTTP . . . . . . . . . . . . . . . . . . .  6
     5.4.  JSON Schema and other protocols  . . . . . . . . . . . . .  6
     5.5.  Mathematical integers  . . . . . . . . . . . . . . . . . .  7
     5.6.  Extending JSON Schema  . . . . . . . . . . . . . . . . . .  7
     5.7.  Security considerations  . . . . . . . . . . . . . . . . .  7
   6.  The "$schema" keyword  . . . . . . . . . . . . . . . . . . . .  7
     6.1.  Purpose  . . . . . . . . . . . . . . . . . . . . . . . . .  7
     6.2.  Customization  . . . . . . . . . . . . . . . . . . . . . .  8
   7.  Schema addressing  . . . . . . . . . . . . . . . . . . . . . .  8
     7.1.  Addressing mechanisms  . . . . . . . . . . . . . . . . . .  8
     7.2.  URI of a root schema . . . . . . . . . . . . . . . . . . .  8
     7.3.  Canonical addressing . . . . . . . . . . . . . . . . . . .  8
     7.4.  Inline addressing  . . . . . . . . . . . . . . . . . . . .  9
       7.4.1.  JSON Reference extension . . . . . . . . . . . . . . . 10
     7.5.  Security considerations  . . . . . . . . . . . . . . . . . 10
   8.  Schema/Instance Association  . . . . . . . . . . . . . . . . . 10
     8.1.  Purpose of this section  . . . . . . . . . . . . . . . . . 10
     8.2.  Recommended correlation mechanisms for use with the
           HTTP protocol  . . . . . . . . . . . . . . . . . . . . . . 11
       8.2.1.  Correlation by means of the "Content-Type" header  . . 11
       8.2.2.  Correlation by means of the "Link" header  . . . . . . 11
   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 11
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 11
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 11
     10.2. Informative References . . . . . . . . . . . . . . . . . . 12
   Appendix A.  ChangeLog . . . . . . . . . . . . . . . . . . . . . . 12





Galiegue                  Expires July 16, 2013                 [Page 2]

Internet-Draft                 JSON Schema                  January 2013


1.  Introduction

   JSON Schema is a JSON media type for defining the structure of JSON
   data.  JSON Schema provides a contract for what JSON data is required
   for a given application and how to interact with it.  JSON Schema is
   intended to define validation, documentation, hyperlink navigation,
   and interaction control of JSON data.

   This specification defines JSON Schema core terminology and
   mechanisms; related specifications build upon this specification and
   define different applications of JSON Schema.

2.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

   The terms "JSON", "JSON text", "JSON value", "member", "element",
   "object", "array", "number", "string", "boolean", "true", "false",
   and "null" in this document are to be interpreted as defined in RFC
   4627 [RFC4627].

3.  Core terminology

3.1.  Property, item

   When refering to a JSON Object, as defined by [RFC4627], the terms
   "member" and "property" may be used interchangeably.

   When refering to a JSON Array, as defined by [RFC4627], the terms
   "element" and "item" may be used interchangeably.

3.2.  JSON Schema, keywords

   A JSON Schema is a JSON document, and that document MUST be an
   object.  Object members (or properties) defined by JSON Schema (this
   specification, or related specifcations) are called keywords, or
   schema keywords.

   A JSON Schema MAY contain properties which are not schema keywords.

3.3.  Empty schema

   An empty schema is a JSON Schema with no properties, or with
   properties which are not schema keywords.





Galiegue                  Expires July 16, 2013                 [Page 3]

Internet-Draft                 JSON Schema                  January 2013


3.4.  Root schema, subschema

   This example of a JSON Schema has no subschemas:


   {
       "title": "root"
   }


   JSON Schemas can also be nested, as in this example:


   {
       "title": "root",
       "otherSchema": {
           "title": "nested",
           "anotherSchema": {
               "title": "alsoNested"
           }
       }
   }


   In this example, "nested" and "alsoNested" are subschemas, and "root"
   is a root schema.

3.5.  JSON Schema primitive types

   JSON Schema defines seven primitive types for JSON values:

   array  A JSON array.

   boolean  A JSON boolean.

   integer  A JSON number without a fraction or exponent part.

   number  Any JSON number.  Number includes integer.

   null  The JSON null value.

   object  A JSON object.

   string  A JSON string.







Galiegue                  Expires July 16, 2013                 [Page 4]

Internet-Draft                 JSON Schema                  January 2013


3.6.  JSON value equality

   Two JSON values are said to be equal if and only if:

      both are nulls; or

      both are booleans, and have the same value; or

      both are strings, and have the same value; or

      both are numbers, and have the same mathematical value; or

      both are arrays, and:

         have the same number of items; and

         items at the same index are equal according to this definition;
         or

      both are objects, and:

         have the same set of property names; and

         values for a same property name are equal according to this
         definition.

3.7.  Instance

   An instance is any JSON value.  An instance may be described by one
   or more schemas.

   An instance may also be referred to as "JSON instance", or "JSON
   data".

4.  Overview

   This document proposes a new media type "application/schema+json" to
   identify JSON Schema for describing JSON data.  JSON Schemas are
   themselves written in JSON.  This, and related specifications, define
   keywords allowing to describe this data in terms of allowable values,
   textual descriptions and interpreting relations with other resources.
   The following sections are a summary of features defined by related
   specifications.

4.1.  Validation

   JSON Schema allows applications to validate instances, either non
   interactively or interactively.  For instance, an application may



Galiegue                  Expires July 16, 2013                 [Page 5]

Internet-Draft                 JSON Schema                  January 2013


   collect JSON data and check that this data matches a given set of
   constraints; another application may use a JSON Schema to build an
   interactve interface in order to collect user input according to
   constraints described by JSON Schema.

4.2.  Hypermedia and linking

   JSON Schema provides a method for extracting link relations from
   instances to other resources, as well as describing interpretations
   of instances as multimedia data.  This allows JSON data to be
   interpreted as rich hypermedia documents, placed in the context of a
   larger set of related resources.

5.  General considerations

5.1.  Applicability to all JSON values

   It is acknowledged that an instance may be any valid JSON value as
   defined by [RFC4627].  As such, JSON Schema does not mandate that an
   instance be of a particular type: JSON Schema can describe any JSON
   value, including null.

5.2.  Programming language independence

   JSON Schema is programming language agnostic.  The only limitations
   are the ones expressed by [RFC4627] and those of the host programming
   language.

5.3.  JSON Schema and HTTP

   This specification acknowledges the role of HTTP [RFC2616] as the
   dominant protocol in use on the Internet, and the wealth of official
   specifications related to it.

   This specification uses a subset of these specifications to recommend
   a set of mechanisms, usable by this protocol, to associate JSON
   instances to one or more schemas.

5.4.  JSON Schema and other protocols

   JSON Schema does not define any semantics for the client-server
   interface for any other protocols than HTTP.  These semantics are
   application dependent, or subject to agreement between the parties
   involved in the use of JSON Schema for their own needs.







Galiegue                  Expires July 16, 2013                 [Page 6]

Internet-Draft                 JSON Schema                  January 2013


5.5.  Mathematical integers

   It is acknowledged by this specification that some programming
   languages, and their associated parsers, use different internal
   representations for floating point numbers and integers, while others
   do not.

   As a consequence, for interoperability reasons, any JSON used in the
   context of JSON Schema, whether that JSON be a JSON Schema or an
   instance, SHOULD ensure that mathematical integers be represented as
   integers as defined by this specification.

5.6.  Extending JSON Schema

   Implementations MAY choose to define additional keywords to JSON
   Schema.  Save for explicit agreement, schema authors SHALL NOT expect
   these additional keywords to be supported by peer implementations.
   Implementations SHOULD ignore keywords they do not support.

5.7.  Security considerations

   Both schemas and instances are JSON values.  As such, all security
   considerations defined in RFC 4627 [RFC4627] apply.

6.  The "$schema" keyword

6.1.  Purpose

   The "$schema" keyword is both used as a JSON Schema version
   identifier and the location of a resource which is itself a JSON
   Schema, which describes any schema written for this particular
   version.

   This keyword MUST be located at the root of a JSON Schema.  The value
   of this keyword MUST be a URI, and this URI MUST be both absolute and
   normalized.  The resource located at this URI MUST successfully
   describe itself.  It is RECOMMENDED that schema authors include this
   keyword in their schemas.

   The following values are predefined:

      "http://json-schema.org/schema#" (JSON Schema written against the
      current version of the specification);

      "http://json-schema.org/draft-04/schema#" (JSON Schema written
      against the current version of the specification);





Galiegue                  Expires July 16, 2013                 [Page 7]

Internet-Draft                 JSON Schema                  January 2013


      "http://json-schema.org/draft-04/hyper-schema#" (JSON Schema
      hyperschema written against JSON Schema, draft v4);

      "http://json-schema.org/draft-03/schema#" (JSON Schema written
      against JSON Schema, draft v3 [json-schema-03]);

      "http://json-schema.org/draft-03/hyper-schema#" (JSON Schema
      hyperschema written against JSON Schema, draft v3
      [json-schema-03]).

6.2.  Customization

   When extending JSON Schema with custom keywords, schema authors
   SHOULD define a custom URI to use for "$schema".  This custom URI
   MUST NOT be one of the predefined values.

7.  Schema addressing

7.1.  Addressing mechanisms

   JSON Schema addressing is done using URIs [RFC3986].  Two addressing
   mechanisms are defined: canonical addressing and inline addressing.
   Implementations MUST support canonical addressing, and MAY support
   inline addressing.

   Inline addressing is done by the means of the "id" keyword.  When
   present, the value of this keyword MUST be a string; this string MUST
   be a valid URI, and SHOULD be normalized.

7.2.  URI of a root schema

   When a schema is loaded via a URI, the loading URI SHALL be
   considered to be the URI for this schema.  If a schema is loaded
   without a URI:

      if "id" is present in the root schema, its value MAY be considered
      to be the schema URI;

      otherwise, it is RECOMMENDED that implementations consider that
      the URI of the schema is either the empty URI, or a URN.

7.3.  Canonical addressing

   Canonical addressing in JSON Schema is done using JSON Reference
   [json-reference].  JSON References, when encountered, MUST be
   resolved against the URI of the current root schema.





Galiegue                  Expires July 16, 2013                 [Page 8]

Internet-Draft                 JSON Schema                  January 2013


7.4.  Inline addressing

   When "id" is encountered in a subschema, implementations MAY resolve
   this URI against the URI of a root schema, and consider that the
   canonical URI of this subschema is the calculated URI.  This is
   called inline addressing.

   There SHOULD NOT be two identical "id" values in the same root schema
   which resolve to the same URI.  If this is the case, subschema lookup
   using inline addressing is undefined.

   This schema will be taken as an example:


   {
       "id": "http://x.y.z/rootschema.json#",
       "schema1": {
           "id": "#foo"
       },
       "schema2": {
           "id": "otherschema.json",
           "nested": {
               "id": "#bar"
           },
           "alsonested": {
               "id": "t/inner.json#a"
           }
       },
       "schema3": {
           "id": "some://where.else/completely#"
       }
   }


   Subschemas at the following URI-encoded JSON Pointer [json-pointer]s
   (starting from the root schema) have the following URIs:

   # (document root)  http://x.y.z/rootschema.json#

   #/schema1  http://x.y.z/rootschema.json#foo

   #/schema2  http://x.y.z/otherschema.json#

   #/schema2/nested  http://x.y.z/rootschema.json#bar







Galiegue                  Expires July 16, 2013                 [Page 9]

Internet-Draft                 JSON Schema                  January 2013


   #/schema2/alsonested  http://x.y.z/t/inner.json#a

   #/schema3  some://where.else/completely#

7.4.1.  JSON Reference extension

   The JSON Reference specification mandates that the fragment part of a
   reference, if any, be a JSON Pointer.  However, this would prevent
   some of the URIs in the example above from being addressable.  Schema
   authors MAY use an extended form of a JSON Reference for inline
   addressing, such as in this example:


   {
       "$ref": "http://x.y.z/t/inner.json#a
   }


   An implementation choosing to support inline addressing SHOULD
   support this extension to JSON Reference.

7.5.  Security considerations

   Inline addressing can produce canonical URIs which differ from the
   canonical URI of the root schema.  Implementations MAY choose, for
   security reasons, to ignore inline addressing in such a situation,
   and fall back to canonical addressing.

   Dereferencing URIs MAY fail to complete, or MAY procude content which
   is not a JSON Schema (another type of JSON value, or not a JSON
   value).  It is RECOMMENDED that JSON Schema processing be considered
   a failure in such a situation.

8.  Schema/Instance Association

8.1.  Purpose of this section

   A JSON instance MAY be correlated to one, or even several, JSON
   Schemas.  This correlation MAY be embodied within existing protocol
   headers.

   In addition, if the protocol also carries media type information (by
   means, for instance, of a "Content-Type" header), an instance MUST be
   one of "application/json" or any other subtype.

   Should the scenario above be inapplicable, due either to the absence
   of, or restrictions on, protocol headers, such a correlation is out
   of the normative scope of this specification.



Galiegue                  Expires July 16, 2013                [Page 10]

Internet-Draft                 JSON Schema                  January 2013


8.2.  Recommended correlation mechanisms for use with the HTTP protocol

   It is acknowledged by this specification that the majority of
   interactive JSON Schema processing will be over HTTP.  This section
   therefore gives recommendations for materializing an instance/schema
   correlation using mechanisms currently available for this protocol.

8.2.1.  Correlation by means of the "Content-Type" header

   It is RECOMMENDED that a MIME type parameter by the name of "profile"
   be appended to the "Content-Type" header of the instance being
   processed.  If present, the value of this parameter MUST be a valid
   URI, and this URI SHOULD resolve to a valid JSON Schema.

   An example of such a header would be:


   Content-Type: application/my-media-type+json;
                 profile=http://example.com/my-hyper-schema


8.2.2.  Correlation by means of the "Link" header

   When using the "Link" header, the relation type used MUST be
   "describedBy", as defined by RFC 5988, section 5.3 [RFC5988].  The
   target URI of the "Link" header SHOULD be a valid JSON Schema.

   An example of such a header would be:


   Link: <http://example.com/my-hyper-schema#>; rel="describedBy"


9.  IANA Considerations

   The proposed MIME media type for JSON Schema is defined as follows:

      type name: application;

      subtype name: schema+json.

10.  References

10.1.  Normative References

   [RFC2119]         Bradner, S., "Key words for use in RFCs to Indicate
                     Requirement Levels", BCP 14, RFC 2119, March 1997.




Galiegue                  Expires July 16, 2013                [Page 11]

Internet-Draft                 JSON Schema                  January 2013


10.2.  Informative References

   [RFC2616]         Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                     Masinter, L., Leach, P., and T. Berners-Lee,
                     "Hypertext Transfer Protocol -- HTTP/1.1",
                     RFC 2616, June 1999.

   [RFC3986]         Berners-Lee, T., Fielding, R., and L. Masinter,
                     "Uniform Resource Identifier (URI): Generic
                     Syntax", STD 66, RFC 3986, January 2005.

   [RFC4627]         Crockford, D., "The application/json Media Type for
                     JavaScript Object Notation (JSON)", RFC 4627,
                     July 2006.

   [RFC5988]         Nottingham, M., "Web Linking", RFC 5988,
                     October 2010.

   [json-reference]  Bryan, P. and K. Zyp, "JSON Reference (work in
                     progress)", September 2012, <http://tools.ietf.org/
                     html/draft-pbryan-zyp-json-ref-03>.

   [json-pointer]    Bryan, P. and K. Zyp, "JSON Pointer (work in
                     progress)", September 2012, <http://tools.ietf.org/
                     html/draft-ietf-appsawg-json-pointer-07>.

   [json-schema-03]  Court, G. and K. Zyp, "JSON Schema, draft 3",
                     September 2012, <http://tools.ietf.org/html/
                     draft-zyp-json-schema-03>.

Appendix A.  ChangeLog

   draft-00

      *  Initial draft.

Author's Address

   Francis Galiegue

   EMail: fgaliegue@gmail.com










Galiegue                  Expires July 16, 2013                [Page 12]

