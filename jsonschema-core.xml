<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC6839 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6839.xml">
<!ENTITY RFC6901 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6901.xml">
<!ENTITY RFC7049 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC8259 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8259.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC8288 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8288.xml">
<!ENTITY ldp SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml4/reference.W3C.REC-ldp-20150226.xml">
<!ENTITY fragid-best-practices SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml4/reference.W3C.WD-fragid-best-practices-20121025.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes" ?>
<rfc category="info" docName="draft-handrews-json-schema-02" ipr="trust200902">
    <front>
        <title abbrev="JSON Schema">JSON Schema: A Media Type for Describing JSON Documents</title>

        <author fullname="Austin Wright" initials="A" surname="Wright" role="editor">
            <address>
                <email>aaa@bzfx.net</email>
            </address>
        </author>

        <author fullname="Henry Andrews" initials="H" surname="Andrews" role="editor">
            <address>
                <postal>
                    <street></street>
                    <city>San Francisco</city>
                    <region>CA</region>
                    <country>USA</country>
                </postal>
                <email>henry@cloudflare.com</email>
            </address>
        </author>

      <author fullname="Ben Hutton" initials="B" surname="Hutton" role="editor">
            <organization>Wellcome Sanger Institute</organization>
            <address>
                <email>bh7@sanger.ac.uk</email>
            </address>
        </author>

        <author fullname="Greg Dennis" initials="G" surname="Dennis">
            <address>
                <postal>
                    <street></street>
                    <city>Auckland</city>
                    <region></region>
                    <country>NZ</country>
                </postal>
                <email>gregsdennis@yahoo.com</email>
            </address>
        </author>

        <date year="2019"/>
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema defines the media type "application/schema+json", a JSON-based format
                for describing the structure of JSON data.
                JSON Schema asserts what a JSON document must look like,
                ways to extract information from it,
                and how to interact with it.
                The "application/schema-instance+json" media type provides additional
                feature-rich integration with "application/schema+json" beyond what can be offered
                for "application/json" documents.
            </t>
        </abstract>
        <note title="Note to Readers">
            <t>
                The issues list for this draft can be found at
                <eref target="https://github.com/json-schema-org/json-schema-spec/issues"/>.
            </t>
            <t>
                For additional information, see <eref target="http://json-schema.org/"/>.
            </t>
            <t>
                To provide feedback, use this issue tracker, the communication methods listed on the
                homepage, or email the document editors.
            </t>
        </note>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Schema is a JSON media type for defining the structure of JSON data. JSON Schema
                is intended to define validation, documentation, hyperlink navigation, and interaction
                control of JSON data.
            </t>
            <t>
                This specification defines JSON Schema core terminology and mechanisms, including
                pointing to another JSON Schema by reference,
                dereferencing a JSON Schema reference,
                specifying the vocabulary being used,
                and defining the expected output.
            </t>
            <t>
                Other specifications define the vocabularies that perform assertions about validation,
                linking, annotation, navigation, and interaction.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in <xref target="RFC8259">RFC 8259</xref>.
            </t>
        </section>

        <section title="Overview">
            <t>
                This document proposes a new media type "application/schema+json" to identify a JSON
                Schema for describing JSON data.
                It also proposes a further optional media type, "application/schema-instance+json",
                to provide additional integration features.
                JSON Schemas are themselves JSON documents.
                This, and related specifications, define keywords allowing authors to describe JSON
                data in several ways.
            </t>

            <section title="Keyword Behaviors">
                <t>
                    JSON Schema keywords fall into several general behavior categories.
                    Assertions validate that an instance satisfies constraints, producing
                    a boolean result.  Annotations attach information that applications
                    may use in any way they see fit.
                    Applicators apply subschemas to parts of the instance and combine
                    their results.
                </t>
                <t>
                    Extension keywords SHOULD stay within these categories, keeping in mind
                    that annotations in particular are extremely flexible.  Complex behavior
                    is usually better delegated to applications on the basis of annotation
                    data than implemented directly as schema keywords.  However, extension
                    keywords MAY define other behaviors for specialized purposes.
                </t>
                <t>
                    Evaluating an instance against a schema involves processing all of the
                    keywords in the schema against the appropriate locations within the instance.
                    Typically, applicator keywords are processed until a schema object with no
                    applicators (and therefore no subschemas) is reached.  The appropriate
                    location in the instance is evaluated against the assertion and
                    annotation keywords in the schema object, and their results are gathered
                    into the parent schema according to the rules of the applicator.
                </t>
                <t>
                    Evaluation of a parent schema object can complete once all of its
                    subschemas have been evaluated, although in some circumstances evaluation
                    may be short-circuited due to assertion results.
                </t>
                <section title="Keyword Interactions">
                    <t>
                        Keyword behavior MAY be defined in terms of the annotation results
                        of <xref target="root">subschemas</xref> and/or adjacent keywords.
                        Such keywords MUST NOT result in a circular dependency.
                        Keywords MAY modify their behavior based on the presence or absence
                        of another keyword in the same
                        <xref target="schema-document">schema object</xref>.
                    </t>
                </section>
                <section title="Default Behaviors">
                    <t>
                        A missing keyword MUST NOT produce a false assertion result, MUST
                        NOT produce annotation results, and MUST NOT cause any other schema
                        to be evaluated as part of its own behavioral definition.
                        However, given that missing keywords do not contribute annotations,
                        the lack of annotation results may indirectly change the behavior
                        of other keywords.
                    </t>
                    <t>
                        In some cases, the missing keyword assertion behavior of a keyword is
                        identical to that produced by a certain value, and keyword definitions
                        SHOULD note such values where known.  However, even if the value which
                        produces the default behavior would produce annotation results if
                        present, the default behavior still MUST NOT result in annotations.
                    </t>
                    <t>
                        Because annotation collection can add significant cost in terms of both
                        computation and memory, implementations MAY opt out of this feature.
                        Keywords known to an implementation to have assertion or applicator behavior
                        that depend on annotation results MUST then be treated as errors, unless
                        an alternate implementation producing the same behavior is available.
                        Keywords of this sort SHOULD describe reasonable alternate approaches
                        when appropriate.  This approach is demonstrated by the
                        "<xref target="additionalItems" format="title"/>" and
                        "<xref target="additionalProperties" format="title"/>" keywords in this
                        document.
                    </t>
                </section>
                <section title="Applicators" anchor="applicators">
                    <t>
                        Applicators allow for building more complex schemas than can be accomplished
                        with a single schema object.  Evaluation of an instance against a
                        <xref target="schema-document">schema document</xref> begins by applying
                        the <xref target="root">root schema</xref> to the complete instance
                        document.  From there, keywords known as applicators are used to determine
                        which additional schemas are applied.  Such schemas may be applied in-place
                        to the current location, or to a child location.
                    </t>
                    <t>
                        The schemas to be applied may be present as subschemas comprising all or
                        part of the keyword's value.  Alternatively, an applicator may refer to
                        a schema elsewhere in the same schema document, or in a different one.
                        The mechanism for identifying such referenced schemas is defined by the
                        keyword.
                    </t>
                    <t>
                        Applicator keywords also define how subschema or referenced schema
                        boolean <xref target="assertions">assertion</xref>
                        results are modified and/or combined to produce the boolean result
                        of the applicator.  Applicators may apply any boolean logic operation
                        to the assertion results of subschemas, but MUST NOT introduce new
                        assertion conditions of their own.
                    </t>
                    <t>
                        <xref target="annotations">Annotation</xref> results are
                        combined according to the rules specified by each annotation keyword.
                    </t>
                </section>

                <section title="Assertions" anchor="assertions">
                    <t>
                        JSON Schema can be used to assert constraints on a JSON document, which
                        either passes or fails the assertions.  This approach can be used to validate
                        conformance with the constraints, or document what is needed to satisfy them.
                    </t>
                    <t>
                        JSON Schema implementations produce a single boolean result when evaluating
                        an instance against schema assertions.
                    </t>
                    <t>
                        An instance can only fail an assertion that is present in the schema.

                    </t>
                    <section title="Assertions and Instance Primitive Types">
                        <t>
                            Most assertions only constrain values within a certain
                            primitive type.  When the type of the instance is not of the type
                            targeted by the keyword, the instance is considered to conform
                            to the assertion.
                        </t>
                        <t>
                            For example, the "maxLength" keyword from the companion validation
                            vocabulary will only restrict certain strings
                            (that are too long) from being valid.  If the instance is a number,
                            boolean, null, array, or object, then it is valid against this assertion.
                        </t>
                    </section>
                </section>

                <section title="Annotations" anchor="annotations">
                    <t>
                        JSON Schema can annotate an instance with information, whenever the instance
                        validates against the schema object containing the annotation, and all of its
                        parent schema objects.  The information can be a simple value, or can be
                        calculated based on the instance contents.
                    </t>
                    <t>
                        Annotations are attached to specific locations in an instance.
                        Since many subschemas can be applied to any single
                        location, annotation keywords need to specify any unusual handling of
                        multiple applicable occurrences of the keyword with different values.
                    </t>
                    <t>
                        The default behavior is simply to collect all values in a list in
                        indeterminate order.  Given the extensibility of keywords, including
                        applicators, it is not possible to define a universally predictable
                        order of processing.
                    </t>
                    <t>
                        Unlike assertion results, annotation data can take a wide variety of forms,
                        which are provided to applications to use as they see fit.  JSON Schema
                        implementations are not expected to make use of the collected information
                        on behalf of applications.
                    </t>
                    <t>
                        While "short-circuit" evaluation is possible for assertions, collecting
                        annotations requires examining all schemas that apply to an instance
                        location, even if they cannot change the overall assertion result.
                    </t>
                </section>
            </section>

            <section title="Schema Vocabularies" anchor="vocabulary">
                <t>
                    A JSON Schema vocabulary is a set of keywords defined for a particular
                    purpose.  The vocabulary specifies the meaning of its keywords as
                    assertions, annotations, and/or any vocabulary-defined keyword category.
                </t>
                <t>
                    Several vocabularies are provided as
                    standards in this and closely related documents.  These vocabularies
                    are used with the core keywords defined as fundamental to the
                    "application/schema+json" media type.
                </t>
                <t>
                    Schema authors are encouraged to define their own vocabularies for
                    domain-specific concepts.  A vocabulary need not be a standard to
                    be re-usable, although users of extension vocabularies MUST NOT
                    assume that any JSON Schema implementation can support the vocabulary
                    unless it specifically documents such support.
                </t>
                <section title="Subschema Application">
                    <t>
                        This vocabulary provides keywords for applying subschemas to the
                        instance in various ways.  It is defined in this document, and
                        it is RECOMMENDED that all JSON Schema implementations support it.
                        All other vocabularies in this section are designed to be used
                        alongside the subschema application vocabulary.
                    </t>
                    <t>
                        Without this vocabulary or an equivalent one, JSON Schema can only
                        be applied to a JSON document as a whole.  In most cases, schema
                        keywords need to be applied to specific object properties or array items.
                    </t>
                </section>
                <section title="Validation">
                    <t>
                        This vocabulary describes the structure of a JSON document
                        (for instance, required properties and length limitations).
                        Applications can use this information to validate instances (check that
                        constraints are met), or inform interfaces to collect user input
                        such that the constraints are satisfied.
                    </t>
                    <t>
                        Validation behaviour and keywords are specified in
                        <xref target="json-schema-validation">a separate document</xref>.
                    </t>
                </section>
                <section title="Basic Meta-Data">
                    <t>
                        A small set of annotation keywords are defined in
                        <xref target="json-schema-validation">the validation specification</xref>
                        to allow associating common kinds of meta-data with an instance.
                    </t>
                </section>
                <section title="Hypermedia and Linking">
                    <t>
                        JSON Hyper-Schema produces hyperlinks as annotations available for
                        use with a JSON document.  It supports resolving URI Templates
                        and describing the resource and data submission formats required
                        to use an API.
                    </t>
                    <t>
                        Hyper-schema behaviour and keywords are specified in
                        <xref target="json-hyper-schema">a separate document</xref>.
                    </t>
                </section>
            </section>
        </section>

        <section title="Definitions">

            <section title="JSON Document">
                <t>
                    A JSON document is an information resource (series of octets) described by the
                    application/json media type.
                </t>
                <t>
                    In JSON Schema, the terms "JSON document", "JSON text", and "JSON value" are
                    interchangeable because of the data model it defines.
                </t>
                <t>
                    JSON Schema is only defined over JSON documents. However, any document or memory
                    structure that can be parsed into or processed according to the JSON Schema data
                    model can be interpreted against a JSON Schema, including media types like
                    <xref target="RFC7049">CBOR</xref>.
                </t>
            </section>

            <section title="Instance">
                <t>
                    A JSON document to which a schema is applied is known as an "instance".
                </t>

                <section title="Instance Data Model">
                    <t>
                        JSON Schema interprets documents according to a data model. A JSON value
                        interpreted according to this data model is called an "instance".
                    </t>
                    <t>
                        An instance has one of six primitive types, and a range of possible values
                        depending on the type:

                        <list style="hanging">
                            <t hangText="null:">A JSON "null" production</t>
                            <t hangText="boolean:">A "true" or "false" value, from the JSON "true" or "false" productions</t>
                            <t hangText="object:">An unordered set of properties mapping a string to an instance, from the JSON "object" production</t>
                            <t hangText="array:">An ordered list of instances, from the JSON "array" production</t>
                            <t hangText="number:">An arbitrary-precision, base-10 decimal number value, from the JSON "number" production</t>
                            <t hangText="string:">A string of Unicode code points, from the JSON "string" production</t>
                        </list>
                    </t>
                    <t>
                        Whitespace and formatting concerns, including different lexical
                        representations of numbers that are equal within the data model, are thus
                        outside the scope of JSON Schema.  JSON Schema
                        <xref target="vocabulary">vocabularies</xref> that wish
                        to work with such differences in lexical representations SHOULD define
                        keywords to precisely interpret formatted strings within the data model
                        rather than relying on having the original JSON representation Unicode
                        characters available.
                    </t>
                    <t>
                        Since an object cannot have two properties with the same key, behavior for a
                        JSON document that tries to define two properties (the "member" production) with
                        the same key (the "string" production) in a single object is undefined.
                    </t>
                    <t>
                        Note that JSON Schema vocabularies are free to define their own extended
                        type system.  This should not be confused with the core data model types
                        defined here.  As an example, "integer" is a reasonable type for a
                        vocabulary to define as a value for a keyword, but the data model
                        makes no distinction between integers and other numbers.
                    </t>
                </section>

                <section title="Instance Media Types">
                    <t>
                        JSON Schema is designed to fully work with "application/json" documents,
                        as well as media types using the "+json" structured syntax suffix.
                    </t>
                    <t>
                        Some functionality that is useful for working with schemas is
                        defined by each media type, namely media type parameters and
                        URI fragment identifier syntax and semantics.  These features are
                        useful in content negotiation and in calculating URIs for specific
                        locations within an instance, respectively.
                    </t>
                    <t>
                        This specification defines the "application/schema-instance+json"
                        media type in order to allow instance authors to take full advantage
                        of parameters and fragment identifiers for these purposes.
                    </t>
                </section>

                <section title="Instance Equality">
                    <t>
                        Two JSON instances are said to be equal if and only if they are of the same type
                        and have the same value according to the data model. Specifically, this means:

                        <list>
                            <t>both are null; or</t>
                            <t>both are true; or</t>
                            <t>both are false; or</t>
                            <t>both are strings, and are the same codepoint-for-codepoint; or</t>
                            <t>both are numbers, and have the same mathematical value; or</t>
                            <t>both are arrays, and have an equal value item-for-item; or</t>
                            <t>both are objects, and each property in one has exactly one property with
                                a key equal to the other's, and that other property has an equal
                                value.</t>
                        </list>
                    </t>
                    <t>
                        Implied in this definition is that arrays must be the same length,
                        objects must have the same number of members,
                        properties in objects are unordered,
                        there is no way to define multiple properties with the same key,
                        and mere formatting differences (indentation, placement of commas, trailing
                        zeros) are insignificant.
                    </t>
                </section>
            </section>

            <section title="JSON Schema Documents" anchor="schema-document">
                <t>
                    A JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema is itself interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the media type parameter and
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".
                </t>
                <t>
                    A JSON Schema MUST be an object or a boolean.
                </t>
                <section title="JSON Schema Objects and Keywords">
                    <t>
                        Object properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of three categories:
                        <list style="hanging">
                            <t hangText="assertions:">
                                produce a boolean result when applied to an instance
                            </t>
                            <t hangText="annotations:">
                                attach information to an instance for application use
                            </t>
                            <t hangText="applicators:">
                                apply one or more subschemas to a particular location
                                in the instance, and combine or modify their results
                            </t>
                        </list>
                    </t>
                    <t>
                        Keywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.
                    </t>
                    <t>
                        Extension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.
                    </t>
                    <t>
                        A JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be ignored.
                    </t>
                    <t>
                        An empty schema is a JSON Schema with no properties, or only unknown
                        properties.
                    </t>
                </section>
                <section title="Boolean JSON Schemas">
                    <t>
                        The boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertions results, regardless of the
                        instance value.  They never produce annotation results.
                    </t>
                    <t>
                        These boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).
                        <list style="hanging">
                            <t hangText="true:">
                                Always passes validation, as if the empty schema {}
                            </t>
                            <t hangText="false:">
                                Always fails validation, as if the schema { "not":{} }
                            </t>
                        </list>
                        While the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.
                    </t>
                </section>
                <section title="Root Schema and Subschemas" anchor="root">
                    <t>
                        The root schema is the schema that comprises the entire JSON document
                        in question.
                    </t>
                    <t>
                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
{
    "title": "root",
    "items": {
        "title": "array item"
    }
}
]]>
                        </artwork>
                    </figure>
                    <t>
                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.
                    </t>
                    <t>
                        As with the root schema, a subschema is either an object or a boolean.
                    </t>
                </section>
                <section title="Lexical Scope and Dynamic Scope">
                    <t>
                        While most JSON Schema keywords can be evaluated on their own,
                        or at most need to take into account the values or results of
                        adjacent keywords in the same schema object, a few have more
                        complex behavior.
                    </t>
                    <t>
                        The lexical scope of a keyword is determined by the nested JSON
                        data structure of objects and arrays.  The largest such scope
                        is an entire schema document.  The smallest scope is a single
                        schema object with no subschemas.
                    </t>
                    <t>
                        Keywords MAY be defined with a partial value, such as a URI-reference,
                        which must be resolved against another value, such as another
                        URI-reference or a full URI, which is found through the lexical
                        structure of the JSON document.  The "$id" core keyword and
                        the "base" JSON Hyper-Schema keyword are examples of this sort
                        of behavior.  Additionally, "$ref" and "$recursiveRef" from
                        this specification resolve their values in this way, although
                        they do not change how further values are resolved.
                    </t>
                    <t>
                        Note that some keywords, such as "$schema", apply to the lexical
                        scope of the entire schema document, and therefore MUST only
                        appear in the document's root schema.
                    </t>
                    <t>
                        Other keywords may take into account the dynamic scope that
                        exists during the evaluation of a schema, typically together
                        with an instance document.  The outermost dynamic scope is the
                        root schema of the schema document in which processing begins.
                        The path from this root schema to any particular keyword (that
                        includes any "$ref" and "$recursiveRef" keywords that may have
                        been resolved) is considered the keyword's "validation path."
                        <cref>
                            Or should this be the schema object at which processing
                            begins, even if it is not a root?  This has some implications
                            for the case where "$recursiveAnchor" is only allowed in the
                            root schema but processing begins in a subschema.
                        </cref>
                    </t>
                    <t>
                        Lexical and dynamic scopes align until a reference keyword
                        is encountered.  While following the reference keyword jumps
                        from one lexical scope into a different one, from the perspective
                        of dynamic scope, following reference is no different from descending
                        into a subschema present as a value.  A keyword on the far side of
                        that reference that resolves information through the dynamic scope
                        will consider the originating side of the reference to be their
                        dynamic parent, rather than examining the local lexically enclosing parent.
                    </t>
                    <t>
                        The concept of dynamic scope is primarily used with "$recursiveRef",
                        "$recursiveAnchor", and should be considered an advanced feature
                        and used with caution when defining additional keywords.
                    </t>
                </section>
                <section title="Referenced and Referencing Schemas" anchor="referenced">
                    <t>
                        As noted in <xref target="applicators" />, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.
                    </t>
                    <t>
                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.
                    </t>
                    <t>
                        For some by-reference applicators, such as
                        <xref target="ref">"$ref"</xref>, the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$recursiveRef" and "$recursiveAnchor",  may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.
                    </t>
                </section>
            </section>

        </section>

        <section title="Fragment Identifiers" anchor="fragments">
            <t>
                In accordance with section 3.1 of <xref target="RFC6839"></xref>,
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)
            </t>
            <t>
                Additionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.
            </t>
            <t>
                The use of JSON Pointers as URI fragment identifiers is described in
                <xref target="RFC6901">RFC 6901</xref>.
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.
            </t>
            <t>
                Per the W3C's
                <xref target="W3C.WD-fragid-best-practices-20121025">best practices for fragment identifiers</xref>,
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.
            </t>
            <t>
                Defining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the <xref target="id-keyword">"$id" keyword</xref> section.
            </t>
            <t>
            </t>
        </section>

        <section title="General Considerations">

            <section title="Range of JSON Values">
                <t>
                    An instance may be any valid JSON value as defined by <xref target="RFC8259">JSON</xref>.
                    JSON Schema imposes no restrictions on type: JSON Schema can describe any JSON
                    value, including, for example, null.
                </t>
            </section>

            <section title="Programming Language Independence" anchor="language">
                <t>
                    JSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.
                </t>
            </section>

            <section title="Mathematical Integers" anchor="integers">
                <t>
                    Some programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.
                </t>
                <t>
                    For consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.
                </t>
            </section>

            <section title="Regular Expressions" anchor="regex">
                <t>
                    Keywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                     These regular expressions SHOULD be valid according to the
                    <xref target="ecma262">ECMA 262</xref> regular expression dialect.
                </t>
                <t>
                    Furthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:

                    <list>
                        <t>individual Unicode characters, as defined by the <xref
                        target="RFC8259">JSON specification</xref>;</t>
                        <t>simple character classes ([abc]), range character classes ([a-z]);</t>
                        <t>complemented character classes ([^abc], [^a-z]);</t>
                        <t>simple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");</t>
                        <t>range quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;</t>
                        <t>the beginning-of-input ("^") and end-of-input ("$") anchors;</t>
                        <t>simple grouping ("(...)") and alternation ("|").</t>
                    </list>
                </t>
                <t>
                    Finally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".
                </t>
            </section>

            <section title="Extending JSON Schema">
                <t>
                    Additional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD ignore keywords they do not support.
                </t>
                <t>
                    Vocabulary authors SHOULD
                    take care to avoid keyword name collisions if the vocabulary is intended
                    for broad use, and potentially combined with other vocabularies.  JSON
                    Schema does not provide any formal namespacing system, but also does
                    not constrain keyword names, allowing for any number of namespacing
                    approaches.
                </t>
                <t>
                    Vocabularies may build on each other, such as by defining the behavior
                    of their keywords with respect to the behavior of keywords from another
                    vocabulary, or by using a keyword from another vocabulary with
                    a restricted or expanded set of acceptable values.  Not all such
                    vocabulary re-use will result in a new vocabulary that is compatible
                    with the vocabulary on which it is built.  Vocabulary authors SHOULD
                    clearly document what level of compatibility, if any, is expected.
                </t>
                <t>
                    A schema that itself describes a schema is called a meta-schema.
                    Meta-schemas are used to validate JSON Schemas and specify which vocabulary
                    they are using.
                </t>
                <t>
                    Authors of extensions to JSON Schema are encouraged to write their own
                    meta-schemas, which extend the existing meta-schemas using "allOf".
                    This extended meta-schema SHOULD be referenced using the "$schema" keyword, to
                    allow tools to follow the correct behaviour.
                </t>
                <t>
                    The recursive nature of meta-schemas makes the "$recursiveAnchor"
                    and "$recursiveRef" keywords particularly useful for such extensions,
                    as can be seen in the JSON Hyper-Schema meta-schema.
                </t>
            </section>

        </section>

        <section title="Meta-Schemas and Vocabularies">
            <t>
                Two concepts, meta-schemas and vocabularies, are used to inform an implementation
                how to interpret a schema.  A schema S declares its meta-schema M with the "$schema"
                keyword, and meta-schemas declare vocabularies with the "$vocabulary" keyword.
                The vocabularies declared in M are those that are expected to be used in S.
                The meta-schema M may itself use a different set of vocabularies, which are
                declared in its own meta-schema, M'.
            </t>
            <t>
                The role of the meta-schema is to constrain the structure of conforming schemas,
                as well as simplify the process of composing multiple vocabularies into a usable
                feature set.  Schema authoring is expected to be a common activity, so
                schema authors need only understand how to reference a single meta-schema.
            </t>
            <t>
                Meta-schema authoring is an advanced usage of JSON Schema, so the design of
                meta-schema features emphasizes flexibility over simplicity.
            </t>
            <t>
                The role of a vocabulary is to declare which keywords (including sub-keywords
                such as those in JSON Hyper-Schema's Link Description Object) are in use,
                and with which semantics.  The semantics are indicated by the document
                that publicizes the vocabulary URI.  At this time, there is no machine-readable
                description of keywords other than validation rules, which appear in the
                meta-schema.
            </t>
            <t>
                Meta-schemas are separate from vocabularies to allow for the same sets of
                vocabularies to be combined in different ways, and for meta-schema authors
                to impose additional constraints such as forbidding certain keywords, or
                performing unusually strict syntactical validation, as might be done
                during a development and testing cycle.
            </t>
            <section title='The "$schema" Keyword'>
                <t>
                    The "$schema" keyword is both used as a JSON Schema feature set identifier and
                    the location of a resource which is itself a JSON Schema, which describes any
                    schema written for this particular feature set.
                </t>
                <t>
                    The value of this keyword MUST be a <xref target="RFC3986">URI</xref>
                    (containing a scheme) and this URI MUST be normalized.
                    The current schema MUST be valid against the meta-schema identified by this URI.
                </t>
                <t>
                    If this URI identifies a retrievable resource, that resource SHOULD be of
                    media type "application/schema+json".
                </t>
                <t>
                    The "$schema" keyword SHOULD be used in a root schema.
                    It MUST NOT appear in subschemas.
                </t>
                <t>
                    <cref>
                        Using multiple "$schema" keywords in the same document would imply that the
                        feature set and therefore behavior can change within a document.  This would
                        necessitate resolving a number of implementation concerns that have not yet
                        been clearly defined.  So, while the pattern of using "$schema" only in root
                        schemas is likely to remain the best practice for schema authoring,
                        implementation behavior is subject to be revised or liberalized in
                        future drafts.
                    </cref>
                    <!--
                        In particular, the process of validating an instance, including validating a
                        schema as an instance against its meta-schema, only allows for a single set
                        of rules across the entire instance document.  There is no equivalent of
                        changing the meta-schema partway through the validation for non-schema
                        instances.
                    -->
                </t>
                <t>
                    Values for this property are defined elsewhere in this and other documents,
                    and by other parties.
                </t>
            </section>
            <section title='The "$vocabulary" Keyword'>
                <t>
                    The "$vocabulary" keyword, which appears in a meta-schema, identifies
                    what sets of keywords are expected to be used in schemas described
                    by that meta-schema, and with what semantics.  This is conceptually
                    analogous to how most other keywords used in meta-schemas describe
                    the syntax of keywords used in schemas described by that meta-schema.
                </t>
                <t>
                    The value of this keyword MUST be an object.  The property names in the
                    object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                    Each URI that appears as a property name identifies a specific set of
                    keywords and their semantics.
                </t>
                <t>
                    The URI MAY be a URL, but the nature of the retrievable resources is
                    currently undefined, and reserved for future use.  Vocabulary authors
                    SHOULD NOT serve a document at that URL.  A server MAY respond with
                    the relevant protocol's successful "no content" message, such as
                    an HTTP 204 status.
                    <cref>
                        Vocabulary documents may be added in forthcoming drafts.
                        For now, identifying the keyword set is deemed sufficient as that,
                        along with meta-schema validation, is how the current "vocabularies"
                        work today.
                    </cref>
                </t>
                <t>
                    The values of the object properties MUST be booleans.
                    If the value is true, then implementations that do not recognize
                    the vocabulary MUST refuse to process any schemas that declare
                    this meta-schema with "$schema".  If the value is false, implementations
                    that do not recognize the vocabulary MAY choose to proceed with processing
                    such schemas.
                </t>
                <t>
                    When processing a schema that uses an unrecognized vocabulary (the value for
                    the vocabulary is false), keywords declared by that vocabulary are
                    treated like any other unrecognized keyword, and ignored.
                </t>
                <t>
                    The "$vocabulary" keyword SHOULD be used in the root schema of any schema
                    document intended for use as a meta-schema.  It MUST NOT appear in subschemas.
                </t>
                <t>
                    The "$vocabulary" keyword MUST be ignored in schema documents that
                    are not being processed as a meta-schema.  This allows validating
                    a meta-schema M against its own meta-schema M' without requiring
                    the validator to understand the vocabularies declared by M.
                </t>
                <t>
                    Note that the processing restrictions on "$vocabulary" mean that
                    meta-schemas that reference other meta-schemas using "$ref" or
                    similar keywords do not automatically inherit the vocabulary
                    declarations of those other meta-schemas.  All such declarations
                    must be repeated in the root of each schema document intended
                    for use as a meta-schema.  This is demonstrated in
                    <xref target="example-meta-schema">the example meta-schema</xref>.
                </t>
                <t>
                    If "$vocabulary" is absent, an implementation MAY determine
                    behavior based on the meta-schema if it is recognized from the
                    URI value of the referring schema's "$schema" keyword.
                    If the meta-schema, as referenced by the schema, is not recognized,
                    then implementations MUST assume the use of the core vocabulary,
                    and SHOULD assume the use of all vocabularies in this
                    specification and the companion Validation specification.
                </t>
            </section>
            <section title="Detecting a Meta-Schema">
                <t>
                    Implementations MUST recognize a schema as a meta-schema if it
                    is being examined because it was identified as such by another
                    schema's "$schema" keyword.  This means that a single schema
                    document might sometimes be considered a regular schema, and
                    other times be considered a meta-schema.
                </t>
                <t>
                    In the case of examining a schema which is its own meta-schema,
                    when an implementation begins processing it as a regular schema,
                    it is processed under those rules.  However, when loaded a second
                    time as a result of checking its own "$schema" value, it is treated
                    as a meta-schema.  So the same document is processed both ways in
                    the course of one session.
                </t>
                <t>
                    Implementations MAY allow a schema to be passed as a meta-schema,
                    for implementation-specific purposes, such as pre-loading a commonly
                    used meta-schema and checking its vocabulary support requirements
                    up front.  Meta-schema authors MUST NOT expect such features to be
                    interoperable across implementations.
                </t>
            </section>
            <section title="Best Practices for Vocabulary and Meta-Schema Authors">
                <t>
                    Meta-schema authors SHOULD NOT use "$vocabulary" to combine multiple
                    vocabularies that define conflicting syntax or semantics for the same
                    keyword.  As semantic conflicts are not generally detectable through
                    schema validation, implementations are not expected to detect such
                    conflicts.  If conflicting vocabularies are declared, the resulting
                    behavior is undefined.
                </t>
                <t>
                    Vocabulary authors SHOULD provide a meta-schema that validates the
                    expected usage of the vocabulary's keywords.  Such meta-schemas
                    SHOULD NOT forbid additional keywords, and MUST NOT forbid
                    the "$id", "$schema", or "$vocabulary" keywords in the root schema.
                </t>
                <t>
                    It is RECOMMENDED that meta-schema authors reference each vocabulary's
                    meta-schema using the <xref target="allOf">"allOf"</xref> keyword,
                    although other mechanisms for constructing the meta-schema may be
                    appropriate for certain use cases.
                </t>
                <t>
                    Meta-schemas MAY impose additional constraints, including describing
                    keywords not present in any vocabulary, beyond what the meta-schemas
                    associated with the declared vocabularies describe.  This allows for
                    restricting usage to a subset of a vocabulary, and for validating
                    locally defined keywords not intended for re-use.
                </t>
                <t>
                    However, meta-schemas SHOULD NOT contradict any vocabularies that
                    they declare, such as by requiring a different JSON type than
                    the vocabulary expects.  The resulting behavior is undefined.
                </t>
                <t>
                    Meta-schemas intended for local use, with no need to test for
                    vocabulary support in arbitrary implementations, can safely omit
                    "$vocabulary" entirely.
                </t>
            </section>
            <section title="The JSON Schema Core Vocabulary">
                <t>
                    Keywords declared in in this specification that begin with "$" make up
                    the JSON Schema Core vocabulary.  These keywords are either required in
                    order process any schema or meta-schema, including those split across
                    multiple documents, or exist to reserve keywords for purposes that
                    require guaranteed interoperability.
                </t>
                <t>
                    The Core vocabulary MUST be considered mandatory at all times, in order
                    to bootstrap the processing of further vocabularies.  Meta-schemas
                    that use "$vocabulary" MUST explicitly list the Core vocabulary,
                    which MUST have a value of true indicating that it is required.
                </t>
                <t>
                    The behavior of a false value for this vocabulary (and only this
                    vocabulary) is undefined, as is the behavior when "$vocabulary"
                    is present but the Core vocabulary is not included.  However, it
                    is RECOMMENDED that implementations detect these cases and raise
                    an error when they occur.
                </t>
                <t>
                    Meta-schemas that do not use "$vocabulary" MUST be considered to
                    require the Core vocabulary as if its URI were present with a value of true.
                </t>
                <t>
                    The current URI for the Core vocabulary is:
                    <eref target="https://json-schema.org/draft/2019-04/vocab/core"/>.
                </t>
                <t>
                    The current URI for the corresponding meta-schema is:
                    <eref target="https://json-schema.org/draft/2019-04/meta/core"/>.
                </t>
                <t>
                    Updated vocabulary and meta-schema URIs MAY be published between
                    specification drafts in order to correct errors.  Implementations
                    SHOULD consider URIs dated after this specification draft and
                    before the next to indicate the same syntax and semantics
                    as those listed here.
                </t>
            </section>
            <section title="Example Meta-Schema With Vocabulary Declarations"
                     anchor="example-meta-schema">
                <figure>
                    <preamble>
                        This meta-schema explicitly declares both the Core and Applicator
                        vocabularies with its own vocabulary and combines the
                        Core and Applicator meta-schemas with an "allOf".  It does not
                        need to include itself in the "allOf" since it is its own
                        meta-schema.  It additionally applies three modifications to the
                        combination of these vocabularies:
                        <list>
                            <t>
                                It restricts the usage of the Applicator vocabulary
                                by forbidding the keyword prefixed with "unevaluated".
                            </t>
                            <t>
                                It describes a keyword, "pastDate", that is defined by
                                its own vocabulary.
                            </t>
                            <t>
                                It describes a keyword, "localKeyword", that is not
                                part of any vocabulary.
                            </t>
                        </list>
                        Note that it is its own meta-schema, as it relies on both the Core
                        vocabulary (as all schemas do) and the Applicator vocabulary (for
                        "allOf", "properties", and "patternProperties").
                    </preamble>
                    <artwork>
<![CDATA[
{
  "$schema": "https://json-schema.org/draft/2019-04/core-app-example#",
  "$id": "https://json-schema.org/draft/2019-04/core-app-example",
  "$recursiveAnchor": true,
  "$vocabulary": {
    "https://json-schema.org/draft/2019-04/vocab/core": true,
    "https://json-schema.org/draft/2019-04/vocab/applicator": true,
    "https://json-schema.org/draft/2019-04/vocab/core-app-example": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2019-04/meta/core"},
    {"$ref": "https://json-schema.org/draft/2019-04/meta/applicator"}
  ],
  "patternProperties": {
    "^unevaluated.*$": false
  },
  "properties": {
    "pastDate": {
      "$comment": "Defined by vocabulary"
      "type": "string",
      "format": "date"
    },
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}
]]>
                    </artwork>
                    <postamble>
                        As shown above, even though each of the referenced standard
                        meta-schemas declares its corresponding vocabulary, this new
                        meta-schema must re-declare them for itself.  It would be
                        valid to leave the core vocabulary out of the "$vocabulary" keyword,
                        but it needs to be referenced through the "allOf" keyword in order
                        for its terms to be validated.  There is no special case for
                        validation of core keywords.
                    </postamble>
                </figure>
                <t>
                    "localKeyword" and "pastDate" are now valid for any schema that
                    declares this meta-schema for their "$schema".  Note that defining
                    it in this way does not imply the new keywords are valid within an
                    instance to be validated by such a schema.
                </t>
                <t>
                    Although the meta-schema can validate the syntax of "pastDate"
                    within a schema, it is the vocabulary that defines the logic behind
                    the semantic meaning of "pastDate".  Without an understanding of
                    the semantics, an implementation can only validate the syntactic usage
                    of "pastDate".  This is why a schema MUST refuse to validate a schema
                    which uses a meta-schema that declares a required unknown vocabulary.
                </t>
                <t>
                    In order for an implementation to understand the keywords defined by
                    vocabulary, it may be necessary for the user to augment the
                    implementation by writing a plug-in or other extension that the
                    implementation can use to execute the new validation logic.  The
                    mechanisms by which an implementation supports this are not covered
                    by this specification, however it is RECOMMENDED that implementations
                    provide such support.
                </t>
                <t>
                    The standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.
                </t>
            </section>
        </section>

        <section title="Base URI and Dereferencing">
            <t>
                To differentiate between schemas in a vast ecosystem, schemas are
                identified by <xref target="RFC3986">URI</xref>, and can embed references
                to other schemas by specifying their URI.
            </t>

            <section title="Initial Base URI">
                <t>
                    <xref target="RFC3986">RFC3986 Section 5.1</xref> defines how to determine the
                    default base URI of a document.
                </t>
                <t>
                    Informatively, the initial base URI of a schema is the URI at which it was
                    found, whether that was a network location, a local filesystem, or any other
                    situation identifiable by a URI of any known scheme.
                </t>
                <t>
                    If no source is known, or no URI scheme is known for the source, a suitable
                    implementation-specific default URI MAY be used as described in
                    <xref target="RFC3986"> RFC 3986 Section 5.1.4</xref>.  It is RECOMMENDED
                    that implementations document any default base URI that they assume.
                </t>
            </section>

            <section title='The "$id" Keyword' anchor="id-keyword">
                <t>
                    The "$id" keyword defines a URI for the schema, and the base URI that
                    other URI references within the schema are resolved against.
                    A subschema's "$id" is resolved against the base URI of its parent schema.
                    If no parent sets an explicit base with "$id", the base URI is that of the
                    entire document, as determined per
                    <xref target="RFC3986">RFC 3986 section 5</xref>.
                </t>
                <t>
                    If present, the value for this keyword MUST be a string, and MUST represent a
                    valid <xref target="RFC3986">URI-reference</xref>.
                    This value SHOULD be normalized, and SHOULD NOT be an empty fragment &lt;#&gt;
                    or an empty string &lt;&gt;.
                </t>
                <section title="Identifying the root schema">
                    <t>
                        The root schema of a JSON Schema document SHOULD contain an "$id" keyword with
                        an <xref target="RFC3986">absolute-URI</xref> (containing a scheme, but no fragment),
                        or this absolute URI but with an empty fragment.
                        <!-- All of the standard meta-schemas use an empty fragment in their id/$id values. -->
                    </t>
                </section>
                <section title="Changing the base URI within a schema file">
                    <t>
                        When an "$id" sets the base URI, the object containing that "$id" and all of
                        its subschemas can be identified by using a JSON Pointer fragment starting
                        from that location.  This is true even of subschemas that further change the
                        base URI.  Therefore, a single subschema may be accessible by multiple URIs,
                        each consisting of base URI declared in the subschema or a parent, along with
                        a JSON Pointer fragment identifying the path from the schema object that
                        declares the base to the subschema being identified.  Examples of this are
                        shown in section <xref target="idExamples" format="counter"></xref>.
                    </t>
                </section>
                <section title="Location-independent identifiers">
                    <t>
                        Using JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.
                    </t>
                    <t>
                        To specify such a subschema identifier,
                        the "$id" keyword is set to a URI reference with a plain name fragment (not a JSON Pointer fragment).
                        This value MUST begin with the number sign that specifies a fragment ("#"),
                        then a letter ([A-Za-z]),
                        followed by any number of letters, digits ([0-9]), hyphens ("-"), underscores ("_"),
                        colons (":"), or periods (".").
                    </t>
                    <t>
                        The effect of using a fragment in "$id" that isn't blank or doesn't follow the
                        plain name syntax is undefined.
                        <cref>
                            How should an "$id" URI reference containing a fragment with other components
                            be interpreted?  There are two cases:  when the other components match
                            the current base URI and when they change the base URI.
                        </cref>
                    </t>
                </section>
                <section title="Schema identification examples" anchor="idExamples">
                    <figure>
                        <preamble>
                            Consider the following schema, which shows "$id" being used to identify
                            the root schema, change the base URI for subschemas, and assign plain
                            name fragments to subschemas:
                        </preamble>
                        <artwork>
<![CDATA[
{
    "$id": "http://example.com/root.json",
    "$defs": {
        "A": { "$id": "#foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$id": "#bar" },
                "Y": { "$id": "t/inner.json" }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}
]]>
                        </artwork>
                    </figure>
                    <t>
                        The schemas at the following URI-encoded <xref target="RFC6901">JSON
                        Pointers</xref> (relative to the root schema) have the following
                        base URIs, and are identifiable by any listed URI in accordance with
                        Section <xref target="fragments" format="counter"></xref> above:
                    </t>
                    <t>
                        <list style="hanging">
                            <t hangText="# (document root)">
                                <list>
                                    <t>http://example.com/root.json</t>
                                    <t>http://example.com/root.json#</t>
                                </list>
                            </t>
                            <t hangText="#/$defs/A">
                                <list>
                                    <t>http://example.com/root.json#foo</t>
                                    <t>http://example.com/root.json#/$defs/A</t>
                                </list>
                            </t>
                            <t hangText="#/$defs/B">
                                <list>
                                    <t>http://example.com/other.json</t>
                                    <t>http://example.com/other.json#</t>
                                    <t>http://example.com/root.json#/$defs/B</t>
                                </list>
                            </t>
                            <t hangText="#/$defs/B/$defs/X">
                                <list>
                                    <t>http://example.com/other.json#bar</t>
                                    <t>http://example.com/other.json#/$defs/X</t>
                                    <t>http://example.com/root.json#/$defs/B/$defs/X</t>
                                </list>
                            </t>
                            <t hangText="#/$defs/B/$defs/Y">
                                <list>
                                    <t>http://example.com/t/inner.json</t>
                                    <t>http://example.com/t/inner.json#</t>
                                    <t>http://example.com/other.json#/$defs/Y</t>
                                    <t>http://example.com/root.json#/$defs/B/$defs/Y</t>
                                </list>
                            </t>
                            <t hangText="#/$defs/C">
                                <list>
                                    <t>urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f</t>
                                    <t>urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f#</t>
                                    <t>http://example.com/root.json#/$defs/C</t>
                                </list>
                            </t>
                        </list>
                    </t>
                </section>
            </section>

            <section title="Schema References">
                <t>
                    Several keywords can be used to reference a schema which is to be applied to the
                    current instance location. "$ref" and "$recursiveRef" are applicator
                    keywords, applying the referenced schema to the instance.  "$recursiveAnchor"
                    is a helper keyword that controls how the referenced schema of "$recursiveRef"
                    is determined.
                </t>
                <t>
                    As the value of "$ref" and "$recursiveRef" are URI References, this allows
                    the possibility to externalise or divide a schema across multiple files,
                    and provides the ability to validate recursive structures through
                    self-reference.
                </t>
                <t>
                    The resolved URI produced by these keywords is not necessarily a network
                    locator, only an identifier. A schema need not be downloadable from the
                    address if it is a network-addressable URL, and implementations SHOULD NOT
                    assume they should perform a network operation when they encounter
                    a network-addressable URI.
                </t>

                <section title='Direct References with "$ref"' anchor="ref">
                    <t>
                        The "$ref" keyword is used to reference a statically identified schema.
                    </t>
                    <t>
                        The value of the "$ref" property MUST be a string which is a URI Reference.
                        Resolved against the current URI base, it identifies the URI of a schema
                        to use.
                    </t>
                </section>

                <section title='Recursive References with "$recursiveRef" and "$recursiveAnchor"'>
                    <t>
                        The "$recursiveRef" and "$recursiveAnchor" keywords are used to construct
                        extensible recursive schemas.  A recursive schema is one that has
                        a reference to its own root, identified by the empty fragment
                        URI reference ("#").
                    </t>
                    <t>
                        Extending a recursive schema with "$ref" alone involves redefining all
                        recursive references in the source schema to point to the root of the
                        extension.  This produces the correct recursive behavior in the extension,
                        which is that all recursion should reference the root of the extension.
                    </t>
                    <figure>
                        <preamble>
                            Consider the following two schemas.  The first schema, identified
                            as "original" as it is the schema to be extended, describes
                            an object with one string property and one recursive reference
                            property, "r".  The second schema, identified as "extension",
                            references the first, and describes an additional things" property,
                            which is an array of recursive references.
                            It also repeats the description of "r" from the original schema.
                        </preamble>
                        <artwork>
<![CDATA[
{
    "$schema": "http://json-schema.org/draft/2019-04/schema#",
    "$id": "https://example.com/original",

    "properties": {
        "name": {
            "type": "string"
        },
        "r": {
            "$ref": "#"
        }
    }
}

{
    "$schema": "http://json-schema.org/draft/2019-04/schema#",
    "$id": "https://example.com/extension",

    "$ref": "original",
    "properties": {
        "r": {
            "$ref": "#"
        },
        "things": {
            "type": "array"
            "items": {
                "$ref": "#"
            }
        }
    }
}
]]>
                        </artwork>
                        <postamble>
                            This apparent duplication is important because
                            it resolves to "https://example.com/extension#", meaning that
                            for instance validated against the extension schema, the value
                            of "r" must be valid according to the extension, and not just the
                            original schema as "r" was described there.
                        </postamble>
                    </figure>
                    <t>
                        This approach is fine for a single recursive field, but the more
                        complicated the original schema, the more redefinitions are necessary
                        in the extension.  This leads to a verbose and error-prone extension,
                        which must be kept synchronized with the original schema if the
                        original changes its recursive fields.
                        This approach can be seen in the meta-schema for JSON Hyper-Schema
                        in all prior drafts.
                    </t>
                    <section title='Enabling Recursion with "$recursiveAnchor"'>
                        <t>
                            The desired behavior is for the recursive reference, "r", in the
                            original schema to resolve to the original schema when that
                            is the only schema being used, but to resolve to the extension
                            schema when using the extension.  Then there would be no need
                            to redefine the "r" property, or others like it, in the extension.
                        </t>
                        <t>
                            In order to create a recursive reference, we must do three things:
                            <list>
                                <t>
                                    In our original schema, indicate that the schema author
                                    intends for it to be extensible recursively.
                                </t>
                                <t>
                                    In our extension schema, indicate that it is intended
                                    to be a recursive extension.
                                </t>
                                <t>
                                    Use a reference keyword that explicitly activates the
                                    recursive behavior at the point of reference.
                                </t>
                            </list>
                            These three things together ensure that all schema authors
                            are intentionally constructing a recursive extension, which in
                            turn gives all uses of the regular "$ref" keyword confidence
                            that it only behaves as it appears to, using lexical scoping.
                        </t>
                        <t>
                            The "$recursiveAnchor" keyword is how schema authors indicate
                            that a schema can be extended recursively, and be a recursive
                            schema.  This keyword MAY appear in the root schema of a
                            schema document, and MUST NOT appear in any subschema.
                        </t>
                        <t>
                            The value of "$recursiveAnchor" MUST be of type boolean, and
                            MUST be true.  The value false is reserved for possible future use.
                        </t>
                    </section>
                    <section title='Dynamically recursive references with "$recursiveRef"'>
                        <t>
                            The "$recursiveRef" keyword behaves identically to "$ref", except
                            that if the referenced schema has "$recursiveAnchor" set to true,
                            then the implementation MUST examine the dynamic scope for the
                            outermost (first seen) schema document with "$recursiveAnchor"
                            set to true.  If such a schema document exists, then the target
                            of the "$recursiveRef" MUST be set to that document's URI, in
                            place of the URI produced by the rules for "$ref".
                        </t>
                        <t>
                            Note that if the schema referenced by "$recursiveRef" does not
                            contain "$recursiveAnchor" set to true, or if there are no other
                            "$recursiveAnchor" keywords set to true anywhere further back in
                            the dynamic scope, then "$recursiveRef"'s behavior is identical
                            to that of "$ref".
                        </t>
                        <figure>
                            <preamble>
                                With this in mind, we can rewrite the previous example:
                            </preamble>
                            <artwork>
<![CDATA[
{
    "$schema": "http://json-schema.org/draft/2019-04/schema#",
    "$id": "https://example.com/original",
    "$recursiveAnchor": true,

    "properties": {
        "name": {
            "type": "string"
        },
        "r": {
            "$recursiveRef": "#"
        }
    }
}

{
    "$schema": "http://json-schema.org/draft/2019-04/schema#",
    "$id": "https://example.com/extension",
    "$recursiveAnchor": true,

    "$ref": "original",
    "properties": {
        "things": {
            "type": "array"
            "items": {
                "$recursiveRef": "#"
            }
        }
    }
}
]]>
                            </artwork>
                            <postamble>
                                Note that the "r" property no longer appears in the
                                extension schema.  Instead, all "$ref"s have been changed
                                to "$recursiveRef"s, and both schemas have "$recursiveAnchor"
                                set to true in their root schema.
                            </postamble>
                        </figure>
                        <t>
                            When using the original schema on its own, there is no change
                            in behavior.  The "$recursiveRef" does lead to a schema where
                            "$recursiveAnchor" is set to true, but since the original schema
                            is the only schema document in the dynamics scope (it references
                            itself, and does not reference any other schema documents), the
                            behavior is effectively the same as "$ref".
                        </t>
                        <t>
                            When using the extension schema, the "$recursiveRef" within
                            that schema (for the array items within "things") also effectively
                            behaves like "$ref".  The extension schema is the outermost
                            dynamic scope, so the reference target is not changed.
                        </t>
                        <t>
                            In contrast, when using the extension schema, the "$recursiveRef"
                            for "r" in the original schema now behaves differently.  Its
                            initial target is the root schema of the original schema document,
                            which has "$recursiveAnchor" set to true. In this case, the
                            outermost dynamic scope that also has "$recursiveAnchor" set to
                            true is the extension schema.  So when using the extensions schema,
                            "r"'s reference in the original schema will resolve to
                            "https://example.com/extension#", not "https://example.com/original#".
                        </t>
                    </section>
                </section>

                <section title="Guarding Against Infinite Recursion">
                    <t>
                        A schema MUST NOT be run into an infinite loop against an instance. For
                        example, if two schemas "#alice" and "#bob" both have an "allOf" property
                        that refers to the other, a naive validator might get stuck in an infinite
                        recursive loop trying to validate the instance.  Schemas SHOULD NOT make
                        use of infinite recursive nesting like this; the behavior is undefined.
                    </t>
                </section>

                <section title="References to Possible Non-Schemas">
                    <t>
                        Subschema objects (or booleans) are recognized by their use with known
                        applicator keywords.  These keywords may be the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.
                    </t>
                    <t>
                        Multi-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        <cref>
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
                        </cref>
                    </t>
                    <t>
                        Note that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.
                    </t>
                </section>

                <section title="Loading a referenced schema">
                    <t>
                        The use of URIs to identify remote schemas does not necessarily mean anything is downloaded,
                        but instead JSON Schema implementations SHOULD understand ahead of time which schemas they will be using,
                        and the URIs that identify them.
                    </t>
                    <t>
                        When schemas are downloaded,
                        for example by a generic user-agent that doesn't know until runtime which schemas to download,
                        see <xref target="hypermedia">Usage for Hypermedia</xref>.
                    </t>
                    <t>
                        Implementations SHOULD be able to associate arbitrary URIs with an arbitrary
                        schema and/or automatically associate a schema's "$id"-given URI, depending
                        on the trust that the validator has in the schema.  Such URIs and schemas
                        can be supplied to an implementation prior to processing instances, or may
                        be noted within a schema document as it is processed, producing associations
                        as shown in section <xref target="idExamples" format="counter"></xref>.
                    </t>
                    <t>
                        A schema MAY (and likely will) have multiple URIs, but there is no way for a
                        URI to identify more than one schema. When multiple schemas try to identify
                        as the same URI, validators SHOULD raise an error condition.
                    </t>
                </section>
                <section title="Dereferencing">
                    <t>
                        Schemas can be identified by any URI that has been given to them, including
                        a JSON Pointer or their URI given directly by "$id".  In all cases,
                        dereferencing a "$ref" reference involves first resolving its value as a
                        URI reference against the current base URI per
                        <xref target="RFC3986">RFC 3986</xref>.
                    </t>
                    <t>
                        If the resulting URI identifies a schema within the current document, or
                        within another schema document that has been made available to the implementation,
                        then that schema SHOULD be used automatically.
                    </t>
                    <t>
                        For example, consider this schema:
                    </t>

                    <figure>
                        <artwork>
<![CDATA[
{
    "$id": "http://example.net/root.json",
    "items": {
        "type": "array",
        "items": { "$ref": "#item" }
    },
    "$defs": {
        "single": {
            "$id": "#item",
            "type": "object",
            "additionalProperties": { "$ref": "other.json" }
        }
    }
}
]]>
                        </artwork>
                    </figure>
                    <t>
                        When an implementation encounters the &lt;#/$defs/single&gt; schema,
                        it resolves the "$id" URI reference against the current base URI to form
                        &lt;http://example.net/root.json#item&gt;.
                    </t>
                    <t>
                        When an implementation then looks inside the &lt;#/items&gt; schema, it
                        encounters the &lt;#item&gt; reference, and resolves this to
                        &lt;http://example.net/root.json#item&gt;, which it has seen defined in
                        this same document and can therefore use automatically.
                    </t>
                    <t>
                        When an implementation encounters the reference to "other.json", it resolves
                        this to &lt;http://example.net/other.json&gt;, which is not defined in this
                        document.  If a schema with that identifier has otherwise been supplied to
                        the implementation, it can also be used automatically.
                        <cref>
                            What should implementations do when the referenced schema is not known?
                            Are there circumstances in which automatic network dereferencing is
                            allowed?  A same origin policy?  A user-configurable option?  In the
                            case of an evolving API described by Hyper-Schema, it is expected that
                            new schemas will be added to the system dynamically, so placing an
                            absolute requirement of pre-loading schema documents is not feasible.
                        </cref>
                    </t>
                </section>
            </section>

            <section title='Schema Re-Use With "$defs"'>
                <t>
                    The "$defs" keyword provides a standardized location for schema
                    authors to inline re-usable JSON Schemas into a more general schema.
                    The keyword does not directly affect the validation result.
                </t>
                <t>
                    This keyword's value MUST be an object.
                    Each member value of this object MUST be a valid JSON Schema.
                </t>
                <t>
                    As an example, here is a schema describing an array of positive
                    integers, where the positive integer constraint is a subschema in
                    "$defs":

                    <figure>
                        <artwork>
<![CDATA[
{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}
]]>
                        </artwork>
                    </figure>
                </t>
            </section>
        </section>

        <section title='Comments With "$comment"'>
            <t>
                This keyword is reserved for comments from schema authors to readers or
                maintainers of the schema.

                The value of this keyword MUST be a string. Implementations MUST NOT present this
                string to end users.  Tools for editing schemas SHOULD support displaying and
                editing this keyword.  The value of this keyword MAY be used in debug or error
                output which is intended for developers making use of schemas.

                Schema vocabularies SHOULD allow "$comment" within any object containing
                vocabulary keywords.  Implementations MAY assume "$comment" is allowed
                unless the vocabulary specifically forbids it.  Vocabularies MUST NOT
                specify any effect of "$comment" beyond what is described in this
                specification.

                Tools that translate other media types or programming languages
                to and from application/schema+json MAY choose to convert that media type or
                programming language's native comments to or from "$comment" values.
                The behavior of such translation when both native comments and "$comment"
                properties are present is implementation-dependent.

                Implementations SHOULD treat "$comment" identically to an unknown extension
                keyword.  They MAY strip "$comment" values at any point during processing.
                In particular, this allows for shortening schemas when the size of deployed
                schemas is a concern.

                Implementations MUST NOT take any other action based on the presence, absence,
                or contents of "$comment" properties.  In particular, the value of "$comment"
                MUST NOT be collected as an annotation result.
            </t>
        </section>

        <section title="Collecting Annotations">
            <t>
                Annotations are collected by keywords that explicitly define
                annotation-collecting behavior.  Note that boolean schemas cannot
                produce annotations as they do not make use of keywords.
            </t>
            <t>
                A collected annotation MUST include the following information:
                <list>
                    <t>
                        The name of the keyword that produces the annotation
                    </t>
                    <t>
                        The instance location to which it is attached, as a JSON Pointer
                    </t>
                    <t>
                        The schema location path, indicating how reference keywords
                        such as "$ref" were followed to reach the absolute schema location.
                    </t>
                    <t>
                        The absolute schema location of the attaching keyword, as a URI.
                        This MAY be omitted if it is the same as the schema location path
                        from above.
                    </t>
                    <t>
                        The attached value(s)
                    </t>
                </list>
            </t>
            <t>
                If the same keyword attaches values from multiple schema locations
                to the same instance location, and the annotation defines a process
                for combining such values, then the combined value MUST also be associated
                with the instance location.
            </t>
            <section title="Distinguishing Among Multiple Values">
                <t>
                    Applications MAY make decisions on which of multiple annotation values
                    to use based on the schema location that contributed the value.
                    This is intended to allow flexible usage.  Collecting the schema location
                    facilitates such usage.
                </t>
                <t>
                    For example, consider this schema, which uses annotations and assertions from
                    the <xref target="json-schema-validation">Validation specification</xref>:
                </t>
                <figure>
                    <preamble>
                        Note that some lines are wrapped for clarity.
                    </preamble>
                    <artwork>
<![CDATA[
{
    "title": "Feature list",
    "type": "array",
        "items": [
            {
                "title": "Feature A",
                "properties": {
                    "enabled": {
                        "$ref": "#/$defs/enabledToggle",
                        "default": true
                    }
                }
            },
            {
                "title": "Feature B",
                "properties": {
                    "enabled": {
                        "description": "If set to null, Feature B
                                        inherits the enabled
                                        value from Feature A",
                        "$ref": "#/$defs/enabledToggle"
                    }
                }
            }
        ]
    },
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}
]]>
                    </artwork>
                </figure>
                <t>
                    In this example, both Feature A and Feature B make use of the re-usable
                    "enabledToggle" schema.  That schema uses the "title", "description",
                    and "default" annotations, none of which define special behavior for
                    handling multiple values.  Therefore the application has to decide how
                    to handle the additional "default" value for Feature A, and the additional
                    "description" value for Feature B.
                </t>
                <t>
                    The application programmer and the schema author need to agree on the
                    usage.  For this example, let's assume that they agree that the most
                    specific "default" value will be used, and any additional, more generic
                    "default" values will be silently ignored.  Let's also assume that they
                    agree that all "description" text is to be used, starting with the most
                    generic, and ending with the most specific.  This requires the schema
                    author to write descriptions that work when combined in this way.
                </t>
                <t>
                    The application can use the schema location path to determine which
                    values are which.  The values in the feature's immediate "enabled"
                    property schema are more specific, while the values under the re-usable
                    schema that is referenced to with "$ref" are more generic.  The schema
                    location path will show whether each value was found by crossing a
                    "$ref" or not.
                </t>
                <t>
                    Feature A will therefore use a default value of true, while Feature B
                    will use the generic default value of null.  Feature A will only
                    have the generic description from the "enabledToggle" schema, while
                    Feature B will use that description, and also append its locally
                    defined description that explains how to interpret a null value.
                </t>
                <t>
                    Note that there are other reasonable approaches that a different application
                    might take.  For example, an application may consider the presence of
                    two different values for "default" to be an error, regardless of their
                    schema locations.
                </t>
            </section>
            <section title="Annotations and Assertions">
                <t>
                    Schema objects that produce a false assertion result MUST NOT
                    produce any annotation results, whether from their own keywords
                    or from keywords in subschemas.
                </t>
                <t>
                    Note that the overall schema results may still include annotations
                    collected from other schema locations.  Given this schema:
                </t>
                <figure>
                    <artwork>
<![CDATA[
{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}
]]>
                    </artwork>
                </figure>
                <t>
                    And the instance <spanx style="verb">"This is a string"</spanx>, the
                    title annotation "Integer Value" is discarded because the type assertion
                    in that schema object fails.  The title annotation "String Value"
                    is kept, as the instance passes the string type assertions.
                </t>
            </section>
            <section title="Annotations and Applicators">
                <t>
                    In addition to possibly defining annotation results of their own,
                    applicator keywords aggregate the annotations collected in their
                    subschema(s) or referenced schema(s).  The rules for aggregating
                    annotation values are defined by each annotation keyword, and are
                    not directly affected by the logic used for combining assertion
                    results.
                </t>
            </section>
        </section>

        <section title="A Vocabulary for Applying Subschemas">
            <t>
                This section defines a vocabulary of applicator keywords that
                are RECOMMENDED for use as the basis of other vocabularies.
            </t>
            <t>
                Meta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.
            </t>
            <t>
                The current URI for this vocabulary, known as the Applicator vocabulary, is:
                <eref target="https://json-schema.org/draft/2019-04/vocab/applicator"/>.
            </t>
            <t>
                The current URI for the corresponding meta-schema is:
                <eref target="https://json-schema.org/draft/2019-04/meta/applicator"/>.
            </t>
            <t>
                Updated vocabulary and meta-schema URIs MAY be published between
                specification drafts in order to correct errors.  Implementations
                SHOULD consider URIs dated after this specification draft and
                before the next to indicate the same syntax and semantics
                as those listed here.
            </t>
            <section title="Keyword Independence">
                <t>
                    Schema keywords typically operate independently, without
                    affecting each other's outcomes.
                </t>
                <t>
                    For schema author convenience, there are some exceptions among the
                    keywords in this vocabulary:
                    <list>
                        <t>
                            "additionalProperties", whose behavior is defined in terms of
                            "properties" and "patternProperties"
                        </t>
                        <t>
                            "unevaluatedProperties", whose behavior is defined in terms of
                            annotations from "properties", "patternProperties",
                            "additionalProperties" and itself
                        </t>
                        <t>
                            "additionalItems", whose behavior is defined in terms of "items"
                        </t>
                        <t>
                            "unevaluatedItems", whose behavior is defined in terms of annotations
                            from "items", "additionalItems" and itself
                        </t>
                    </list>
                </t>
            </section>

            <section title="Keywords for Applying Subschemas in Place" anchor="in-place">
                <t>
                    These keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.
                </t>

                <section title="Keywords for Applying Subschemas With Boolean Logic" anchor="logic">
                    <t>
                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.
                    </t>
                    <section title="allOf" anchor="allOf">
                        <t>
                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.
                        </t>
                        <t>
                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.
                        </t>
                    </section>

                    <section title="anyOf">
                        <t>
                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.
                        </t>
                        <t>
                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                        </t>
                    </section>

                    <section title="oneOf">
                        <t>
                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.
                        </t>
                        <t>
                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.
                        </t>
                    </section>

                    <section title="not" anchor="not">
                        <t>
                            This keyword's value MUST be a valid JSON Schema.
                        </t>
                        <t>
                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.
                        </t>
                    </section>
                </section>

                <section title="Keywords for Applying Subschemas Conditionally" anchor="conditional">
                    <t>
                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.
                    </t>
                    <t>
                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.
                    </t>
                    <t>
                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.
                    </t>
                    <section title="if">
                        <t>
                            This keyword's value MUST be a valid JSON Schema.
                        </t>
                        <t>
                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.
                        </t>
                        <t>
                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.
                        </t>
                        <t>
                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.
                        </t>
                        <t>
                            If <xref target="annotations">annotations</xref>
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".
                        </t>
                    </section>
                    <section title="then">
                        <t>
                            This keyword's value MUST be a valid JSON Schema.
                        </t>
                        <t>
                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.
                        </t>
                        <t>
                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.
                        </t>
                    </section>
                    <section title="else">
                        <t>
                            This keyword's value MUST be a valid JSON Schema.
                        </t>
                        <t>
                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.
                        </t>
                        <t>
                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.
                        </t>
                    </section>
                    <section title="dependentSchemas">
                        <t>
                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.
                        </t>
                        <t>
                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.
                        </t>
                        <t>
                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as an empty object.
                        </t>
                    </section>
                </section>
            </section>
            <section title="Keywords for Applying Subschemas to Child Instances">
                <t>
                    Each of these keywords defines a rule for applying its
                    subschema(s) to child instances, specifically object
                    properties and array items, and combining their results.
                </t>
                <section title="Keywords for Applying Subschemas to Arrays">
                    <section title="items">
                        <t>
                            The value of "items" MUST be either a valid JSON Schema or
                            an array of valid JSON Schemas.
                        </t>
                        <t>
                            If "items" is a schema, validation succeeds if all elements
                            in the array successfully validate against that schema.
                        </t>
                        <t>
                            If "items" is an array of schemas, validation succeeds if
                            each element of the instance validates against the schema at the
                            same position, if any.
                        </t>
                        <t>
                            This keyword produces an annotation value which is the largest
                            index to which this keyword applied a subschema.  The value
                            MAY be a boolean true if a subschema was applied to every
                            index of the instance, such as when "items" is a schema.
                        </t>
                        <t>
                            Annotation results for "items" keywords from multiple
                            schemas applied to the same instance location are combined
                            by setting the combined result to true if any of the values
                            are true, and otherwise retaining the largest numerical value.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty schema.
                        </t>
                    </section>

                    <section title="additionalItems" anchor="additionalItems">
                        <t>
                            The value of "additionalItems" MUST be a valid JSON Schema.
                        </t>
                        <t>
                            The behavior of this keyword depends on the presence and
                            annotation result of "items" within the same schema object.
                            If "items" is present, and its annotation result is a number,
                            validation succeeds if every instance element at an index
                            greater than that number validates against "additionalItems".
                        </t>
                        <t>
                            Otherwise, if "items" is absent or its annotation result
                            is the boolean true, "additionalItems" MUST be ignored.
                        </t>
                        <t>
                            If the "additionalItems" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, analogous to the
                            single schema behavior of "items".  If any "additionalItems"
                            keyword from any subschema applied to the same instance
                            location produces an annotation value of true, then
                            the combined result from these keywords is also true.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty schema.
                        </t>
                        <t>
                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of an "items" array.
                            Implementations that do not support annotation collection MUST do so.
                        </t>
                    </section>

                    <section title="unevaluatedItems" anchor="unevaluatedItems">
                        <t>
                            The value of "unevaluatedItems" MUST be a valid JSON Schema.
                        </t>
                        <t>
                            The behavior of this keyword depends on the annotation results of
                            adjacent keywords that apply to the instance location being validated.
                            Specifically, the annotations from "items" and  "additionalItems",
                            which can come from those keywords when they are adjacent to the
                            "unevaluatedItems" keyword.  Those two annotations, as well as
                            "unevaluatedItems", can also result from any and all adjacent
                            <xref target="in-place">in-place applicator</xref> keywords.
                            This includes but is not limited to the in-place applicators
                            defined in this document.
                        </t>
                        <t>
                            If an "items" annotation is present, and its annotation result
                            is a number, and no "additionalItems" or "unevaluatedItems"
                            annotation is present, then validation succeeds if every instance
                            element at an index greater than the "items" annotation validates
                            against "unevaluatedItems".
                        </t>
                        <t>
                            Otherwise, if any "items", "additionalItems", or "unevaluatedItems"
                            annotations are present with a value of boolean true, then
                            "unevaluatedItems" MUST be ignored.  However, if none of these
                            annotations are present, "unevaluatedItems" MUST be applied to
                            all locations in the array.
                        </t>
                        <t>
                            This means that "items", "additionalItems", and all in-place applicators
                            MUST be evaluated before this keyword can be evaluated.  Authors of
                            extension keywords MUST NOT define an in-place applicator that would need
                            to be evaluated before this keyword.
                        </t>
                        <t>
                            If the "unevaluatedItems" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, analogous to the
                            single schema behavior of "items".  If any "unevaluatedItems"
                            keyword from any subschema applied to the same instance
                            location produces an annotation value of true, then
                            the combined result from these keywords is also true.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty schema.
                        </t>
                        <t>
                            Implementations that do not collect annotations MUST raise an error
                            upon encountering this keyword.
                        </t>
                    </section>

                    <section title="contains">
                        <t>
                            The value of this keyword MUST be a valid JSON Schema.
                        </t>
                        <t>
                            An array instance is valid against "contains" if at least one of
                            its elements is valid against the given schema.  This keyword
                            does not produce annotation results.
                            <cref>
                                Should it produce a set of the indices for which the
                                array element is valid against the subschema?  "contains"
                                does not affect "additionalItems" or any other current
                                or proposed keyword, but the information could be useful,
                                and implementation that collect annotations need to
                                apply "contains" to every element anyway.
                            </cref>
                        </t>
                    </section>
                </section>

                <section title="Keywords for Applying Subschemas to Objects">
                    <section title="properties">
                        <t>
                            The value of "properties" MUST be an object.
                            Each value of this object MUST be a valid JSON Schema.
                        </t>
                        <t>
                            Validation succeeds if, for each name that appears in both
                            the instance and as a name within this keyword's value, the child
                            instance for that name successfully validates against the
                            corresponding schema.
                        </t>
                        <t>
                            The annotation result of this keyword is the set of instance
                            property names matched by this keyword.  Annotation results
                            for "properties" keywords from multiple schemas applied to
                            the same instance location are combined by taking the union
                            of the sets.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty object.
                        </t>
                    </section>

                    <section title="patternProperties">
                        <t>
                            The value of "patternProperties" MUST be an object. Each property name
                            of this object SHOULD be a valid regular expression, according to the
                            ECMA 262 regular expression dialect. Each property value of this object
                            MUST be a valid JSON Schema.
                        </t>
                        <t>
                            Validation succeeds if, for each instance name that matches any
                            regular expressions that appear as a property name in this keyword's value,
                            the child instance for that name successfully validates against each
                            schema that corresponds to a matching regular expression.
                        </t>
                        <t>
                            The annotation result of this keyword is the set of instance
                            property names matched by this keyword.  Annotation results
                            for "patternProperties" keywords from multiple schemas applied to
                            the same instance location are combined by taking the union
                            of the sets.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty object.
                        </t>
                    </section>

                    <section title="additionalProperties" anchor="additionalProperties">
                        <t>
                            The value of "additionalProperties" MUST be a valid JSON Schema.
                        </t>
                        <t>
                            The behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".
                        </t>
                        <t>
                            For all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.
                        </t>
                        <t>
                            The annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            Annotation results for "additionalProperties" keywords from
                            multiple schemas applied to the same instance location are combined
                            by taking the union of the sets.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty schema.
                        </t>
                        <t>
                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                        </t>
                    </section>

                    <section title="unevaluatedProperties" anchor="unevaluatedProperties">
                        <t>
                            The value of "unevaluatedProperties" MUST be a valid JSON Schema.
                        </t>
                        <t>
                            The behavior of this keyword depends on the annotation results of
                            adjacent keywords that apply to the instance location being validated.
                            Specifically, the annotations from "properties", "patternProperties",
                            and "additionalProperties", which can come from those keywords when
                            they are adjacent to the "unevaluatedProperties" keyword.  Those
                            three annotations, as well as "unevaluatedProperties", can also
                            result from any and all adjacent
                            <xref target="in-place">in-place applicator</xref> keywords.
                            This includes but is not limited to the in-place applicators
                            defined in this document.
                        </t>
                        <t>
                            Validation with "unevaluatedProperties" applies only to the child
                            values of instance names that do not appear in the "properties",
                            "patternProperties", "additionalProperties", or
                            "unevaluatedProperties" annotation results that apply to the
                            instance location being validated.
                        </t>
                        <t>
                            For all such properties, validation succeeds if the child instance
                            validates against the "unevaluatedProperties" schema.
                        </t>
                        <t>
                            This means that "properties", "patternProperties", "additionalProperties",
                            and all in-place applicators MUST be evaluated before this keyword can
                            be evaluated.  Authors of extension keywords MUST NOT define an in-place
                            applicator that would need to be evaluated before this keyword.
                        </t>
                        <t>
                            The annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            Annotation results for "unevaluatedProperties" keywords from
                            multiple schemas applied to the same instance location are combined
                            by taking the union of the sets.
                        </t>
                        <t>
                            Omitting this keyword has the same assertion behavior as
                            an empty schema.
                        </t>
                        <t>
                            Implementations that do not collect annotations MUST raise an error
                            upon encountering this keyword.
                        </t>
                    </section>

                    <section title="propertyNames">
                        <t>
                            The value of "propertyNames" MUST be a valid JSON Schema.
                        </t>
                        <t>
                            If the instance is an object, this keyword validates if every property name in
                            the instance validates against the provided schema.
                            Note the property name that the schema is testing will always be a string.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as an empty schema.
                        </t>
                    </section>
                </section>
            </section>
        </section>

        <section title="Output Formatting" anchor="output">
            <t>
                JSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.
            </t>

            <section title="Format">
                <t>
                    JSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.
                </t>
            </section>

            <section title="Output Formats">
                <t>
                    This specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.
                    <list>
                        <t>
                            Flag - A boolean which simply indicates the overall validation result
                            with no further details.
                        </t>
                        <t>
                            Basic - Provides validation information in a flat list structure.
                        </t>
                        <t>
                            Detailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.
                        </t>
                        <t>
                            Verbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.
                        </t>
                    </list>
                    An implementation SHOULD provide at least the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    complex formats, it MUST also provide the "flag" format. Implementations SHOULD
                    specify in their documentation which formats they support.
                </t>

            </section>

            <section title="Minimum Information">
                <t>
                    Beyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.
                </t>
                <t>
                    A single object that contains all of these components is considered an
                    output unit.
                </t>
                <t>
                    Implementations MAY elect to provide additional information.
                </t>

                <section title="Keyword Relative Location">
                    <t>
                        The relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$recursiveRef".
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
#/properties/minLength/$ref/minimum
]]>
                        </artwork>
                    </figure>
                    <t>
                    Note that this pointer may not be resolvable due to the inclusion of these
                    applicator keywords.
                    </t>
                    <t>
                        The JSON key for this information is "keywordLocation".
                    </t>
                </section>

                <section title="Keyword Absolute Location">
                    <t>
                        The absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as an absolute URI, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$recursiveRef".
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
http://json-schema.org/draft/2019-04/schema#/$defs/nonNegativeInteger/minimum
]]>
                        </artwork>
                    </figure>
                    <t>
                        This information MAY be omitted only if either the relative location contains
                        no references or if the schema does not declare an absolute URI as its "$id".
                    </t>
                    <t>
                        The JSON key for this information is "absoluteKeywordLocation".
                    </t>
                </section>

                <section title="Instance Location">
                    <t>
                        The location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.
                    </t>
                    <t>
                        The JSON key for this information is "instanceLocation".
                    </t>
                </section>

                <section title="Error or Annotation">
                    <t>
                        The error or annotation that is produced by the validation.
                    </t>
                    <t>
                        For errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.
                    </t>
                    <t>
                        The JSON key for failed validations is "error"; for successful validations
                        it is "annotation".
                    </t>
                </section>

                <section title="Nested Results">
                    <t>
                        For the two hierarchical structures, this property will hold nested errors
                        and annotations.
                    </t>
                    <t>
                        The JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".
                    </t>
                </section>

            </section>

            <section title="Output Structure">
                <t>
                    The output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.
                    <list>
                        <t>
                            "valid" - a boolean value indicating the overall validation success or
                            failure
                        </t>
                        <t>
                            "errors" - the collection of errors or annotations produced by a failed
                            validation
                        </t>
                        <t>
                            "annotations" - the collection of errors or annotations produced by a
                            successful validation
                        </t>
                    </list>
                    For these examples, the following schema and instance will be used.
                </t>
                <figure>
                    <artwork>
<![CDATA[
{
  "$id": "http://example.com/polygon#",
  "$schema": "http://json-schema.org/draft/2019-04/schema#",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3,
  },
  {
    "x": 1,
    "z": 6.7
  }
]
]]>
                    </artwork>
                </figure>
                <t>
                    This instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.
                </t>
                <t>
                    Specifically, the errors it will produce are:
                    <list>
                        <t>
                            The second element in the "vertices" property is missing a "y" property.
                        </t>
                        <t>
                            The second element in the "vertices" property has a disallowed "z" property.
                        </t>
                        <t>
                            There are only two vertices, but three are required.
                        </t>
                    </list>
                    Note that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.
                </t>

                <section title="Flag">
                    <t>
                        In the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
{
  "valid": false
}
]]>
                        </artwork>
                    </figure>
                    <t>
                        Because no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.
                    </t>
                </section>

                <section title="Basic">
                    <t>
                        The "Basic" structure is a flat list of output units.
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "#",
      "instanceLocation": "#",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "#/items/$ref",
      "absoluteKeywordLocation":
        "http://example.com/polygon#/definitions/point",
      "instanceLocation": "#/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "#/items/$ref/required",
      "absoluteKeywordLocation":
        "http://example.com/polygon#/definitions/point/required",
      "instanceLocation": "#/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "#/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "http://example.com/polygon#/definitions/point/additionalProperties",
      "instanceLocation": "#/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "#/minItems",
      "instanceLocation": "#",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}
]]>
                        </artwork>
                    </figure>
                </section>

                <section title="Detailed">
                    <t>
                        The "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correllation is more easily identified.
                    </t>
                    <t>
                        The following rules govern the construction of the results object:
                        <list>
                            <t>
                                All applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.
                            </t>
                            <t>
                                Nodes that have no children are removed.
                            </t>
                            <t>
                                Nodes that have a single child are replaced by the child.
                            </t>
                        </list>
                        Branch nodes do not require an error message or an annotation.
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
{
  "valid": false,
  "keywordLocation": "#",
  "instanceLocation": "#",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "#/items/$ref",
      "absoluteKeywordLocation":
        "http://example.com/polygon#/definitions/point",
      "instanceLocation": "#/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "#/items/$ref/required",
          "absoluteKeywordLocation":
            "http://example.com/polygon#/definitions/point/required",
          "instanceLocation": "#/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "#/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "http://example.com/polygon#/definitions/point/additionalProperties",
          "instanceLocation": "#/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "#/minItems",
      "instanceLocation": "#",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}
]]>
                        </artwork>
                    </figure>
                </section>

                <section title="Verbose">
                    <t>
                        The "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.
                    </t>
                    <t>
                        The primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.
                    </t>
                    <t>
                        Because this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        <eref target="https://json-schema.org/draft/2019-04/output/verbose-example"/>.
                    </t>
                    <figure>
                        <artwork>
<![CDATA[
// schema
{
  "$id": "http://example.com/polygon#",
  "$schema": "http://json-schema.org/draft/2019-04/schema#",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "#",
  "instanceLocation": "#",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "#/type",
      "instanceLocation": "#"
    },
    {
      "valid": true,
      "keywordLocation": "#/properties",
      "instanceLocation": "#"
    },
    {
      "valid": false,
      "keywordLocation": "#/additionalProperties",
      "instanceLocation": "#",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "#/additionalProperties",
          "instanceLocation": "#/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}
]]>
                        </artwork>
                    </figure>
                </section>

                <section title="Output validation schemas">
                    <t>
                        For convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        <eref target="https://json-schema.org/draft/2019-04/output/schema"/>.
                    </t>
                </section>

            </section>

        </section>

        <section title="Usage for Hypermedia" anchor="hypermedia">

            <t>
                JSON has been adopted widely by HTTP servers for automated APIs and robots. This
                section describes how to enhance processing of JSON documents in a more RESTful
                manner when used with protocols that support media types and
                <xref target="RFC8288">Web linking</xref>.
            </t>

            <section title='Linking to a Schema'>
                <t>
                    It is RECOMMENDED that instances described by a schema provide a link to
                    a downloadable JSON Schema using the link relation "describedby", as defined by
                    <xref target="W3C.REC-ldp-20150226">Linked Data Protocol 1.0, section 8.1</xref>.
                </t>

                <t>
                    In HTTP, such links can be attached to any response using the
                    <xref target="RFC8288">Link header</xref>. An example of such a header would be:
                </t>

                <figure>
                    <artwork>
<![CDATA[
Link: <http://example.com/my-hyper-schema#>; rel="describedby"
]]>
                    </artwork>
                </figure>

            </section>


            <section title='Identifying a Schema via a Media Type Parameter' anchor="parameter">
                <t>
                    Media types MAY allow for a "schema" media type parameter, which gives
                    HTTP servers the ability to perform Content-Type Negotiation based on schema.
                    The media-type parameter MUST be a whitespace-separated list of URIs
                    (i.e. relative references are invalid).
                </t>
                <t>
                    When using the media type application/schema-instance+json, the "schema"
                    parameter MUST be supplied.
                </t>
                <t>
                    When using the media type application/schema+json, the "schema" parameter
                    MAY be supplied. If supplied, it SHOULD contain the same URI as identified
                    by the "$schema" keyword, and MAY contain additional URIs.  The "$schema"
                    URI MUST be considered the schema's canonical meta-schema, regardless
                    of the presence of alternative or additional meta-schemas as a media type
                    parameter.
                </t>
                <t>
                    The schema URI is opaque and SHOULD NOT automatically be dereferenced.
                    If the implementation does not understand the semantics of the provided schema,
                    the implementation can instead follow the "describedby" links, if any, which may
                    provide information on how to handle the schema.
                    Since "schema" doesn't necessarily point to a network location, the
                    "describedby" relation is used for linking to a downloadable schema.
                    However, for simplicity, schema authors should make these URIs point to the same
                    resource when possible.
                </t>

                <t>
                    In HTTP, the media-type parameter would be sent inside the Content-Type header:
                </t>

                <figure>
                    <artwork>
<![CDATA[
Content-Type: application/json;
          schema="http://example.com/my-hyper-schema#"
]]>
                    </artwork>
                </figure>

                <t>
                    Multiple schemas are whitespace separated, and indicate that the
                    instance conforms to all of the listed schemas:
                </t>

                <figure>
                    <artwork>
<![CDATA[
Content-Type: application/json;
          schema="http://example.com/alice http://example.com/bob"
]]>
                    </artwork>
                </figure>

                <t>
                    Media type parameters are also used in HTTP's Accept request header:
                </t>

                <figure>
                    <artwork>
<![CDATA[
Accept: application/json;
          schema="http://example.com/qiang http://example.com/li",
        application/json;
          schema="http://example.com/kumar"
]]>
                    </artwork>
                </figure>

                <t>
                    As with Content-Type, multiple schema parameters in the same string
                    requests an instance that conforms to all of the listed schemas.
                </t>

                <t>
                    Unlike Content-Type, Accept can contain multiple values to
                    indicate that the client can accept several media types.
                    In the above example, note that the two media types differ
                    only by their schema parameter values.  This requests an
                    application/json representation that conforms to at least one
                    of the identified schemas.
                </t>

                <t>
                    <cref>
                        This paragraph assumes that we can register a "schema" link relation.
                        Should we instead specify something like "tag:json-schema.org,2017:schema"
                        for now?
                    </cref>
                    HTTP can also send the "schema" in a Link, though this may impact media-type
                    semantics and Content-Type negotiation if this replaces the media-type parameter
                    entirely:
                </t>

                <figure>
                    <artwork>
<![CDATA[
Link: </alice>;rel="schema", </bob>;rel="schema"
]]>
                    </artwork>
                </figure>

            </section>

             <section title="Usage Over HTTP">
                <t>
                    When used for hypermedia systems over a network,
                    <xref target="RFC7231">HTTP</xref> is frequently the protocol of choice for
                    distributing schemas. Misbehaving clients can pose problems for server
                    maintainers if they pull a schema over the network more frequently than
                    necessary, when it's instead possible to cache a schema for a long period of
                    time.
                </t>
                <t>
                    HTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                    HTTP clients SHOULD observe caching headers and not re-request documents within
                    their freshness period.
                    Distributed systems SHOULD make use of a shared cache and/or caching proxy.
                </t>
                <t>
                    Clients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                    implementation or software product. Since symbols are listed in decreasing order
                    of significance, the JSON Schema library name/version should precede the more
                    generic HTTP library name (if any). For example:
                    <figure>
                        <artwork>
<![CDATA[
User-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0
]]>
                        </artwork>
                    </figure>
                </t>
                <t>
                    Clients SHOULD be able to make requests with a "From" header so that server
                    operators can contact the owner of a potentially misbehaving script.
                </t>
            </section>

       </section>

        <section title="Security Considerations" anchor="security">
            <t>
                Both schemas and instances are JSON values. As such, all security considerations
                defined in <xref target="RFC8259">RFC 8259</xref> apply.
            </t>
            <t>
                Instances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas doesn't consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.
            </t>
            <t>
                Servers MUST ensure that malicious parties can't change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".
            </t>
            <t>
                Individual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.
            </t>
            <t>
                Schema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.
            </t>
            <t>
                A malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.
            </t>
        </section>

        <section title="IANA Considerations">
            <section title="application/schema+json">
                <t>
                    The proposed MIME media type for JSON Schema is defined as follows:

                    <list>
                        <t>Type name: application</t>
                        <t>Subtype name: schema+json</t>
                        <t>Required parameters: N/A</t>
                        <t>
                            Optional parameters:
                            <list style="hanging">
                                <t hangText="schema:">
                                    A non-empty list of space-separated URIs, each identifying
                                    a JSON Schema resource.  The instance SHOULD successfully
                                    validate against at least one of these meta-schemas.
                                    Non-validating meta-schemas MAY be included for purposes such
                                    as allowing clients to make use of older versions of
                                    a meta-schema as long as the runtime instance validates
                                    against that older version.
                                </t>
                            </list>
                        </t>
                        <t>
                            Encoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See <xref target="RFC8259">JSON</xref>.
                        </t>
                        <t>
                            Security considerations: See Section
                            <xref target="security" format="counter"></xref> above.
                        </t>
                        <t>
                            Interoperability considerations: See Sections
                            <xref target="language" format="counter"></xref>,
                            <xref target="integers" format="counter"></xref>, and
                            <xref target="regex" format="counter"></xref> above.
                        </t>
                        <t>
                            Fragment identifier considerations: See Section
                            <xref target="fragments" format="counter"></xref>
                        </t>
                    </list>
                </t>
            </section>
            <section title="application/schema-instance+json">
                <t>
                    The proposed MIME media type for JSON Schema Instances that require
                    a JSON Schema-specific media type is defined as follows:

                    <list>
                        <t>Type name: application</t>
                        <t>Subtype name: schema-instance+json</t>
                        <t>
                            Required parameters:
                            <list style="hanging">
                                <t hangText="schema:">
                                    A non-empty list of space-separated URIs, each identifying
                                    a JSON Schema resource.  The instance SHOULD successfully
                                    validate against at least one of these schemas.
                                    Non-validating schemas MAY be included for purposes such
                                    as allowing clients to make use of older versions of a schema
                                    as long as the runtime instance validates against that
                                    older version.
                                </t>
                            </list>
                        </t>
                        <t>
                            Encoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See <xref target="RFC8259">JSON</xref>.
                        </t>
                        <t>
                            Security considerations: See Section
                            <xref target="security" format="counter"></xref> above.
                        </t>
                        <t>
                            Interoperability considerations: See Sections
                            <xref target="language" format="counter"></xref>,
                            <xref target="integers" format="counter"></xref>, and
                            <xref target="regex" format="counter"></xref> above.
                        </t>
                        <t>
                            Fragment identifier considerations: See Section
                            <xref target="fragments" format="counter"></xref>
                        </t>
                    </list>
                </t>
            </section>
        </section>
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &RFC2119;
            &RFC3986;
            &RFC6839;
            &RFC6901;
            &RFC8259;
            &ldp;
            <reference anchor="ecma262"
            target="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">
                <front>
                    <title>ECMA 262 specification</title>
                    <author/>
                    <date/>
                </front>
            </reference>
        </references>

        <references title="Informative References">
            &RFC7049;
            &RFC7231;
            &RFC8288;
            &fragid-best-practices;
            <reference anchor="json-schema-validation">
                <front>
                    <title>JSON Schema Validation: A Vocabulary for Structural Validation of JSON</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <author initials="H." surname="Andrews">
                        <organization/>
                    </author>
                    <author initials="G." surname="Luff">
                        <organization/>
                    </author>
                    <date year="2017" month="November"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-handrews-json-schema-validation-02" />
            </reference>
            <reference anchor="json-hyper-schema">
                <front>
                    <title>JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON</title>
                    <author initials="H." surname="Andrews">
                        <organization/>
                    </author>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <date year="2017" month="November"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-handrews-json-schema-hyperschema-02" />
            </reference>
        </references>

        <section title="Acknowledgments">
            <t>
                Thanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.
            </t>
            <t>
                Thanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Ben Hutton,
                Evgeny Poberezkin,
                Brad Bowman,
                Gowry Sankar,
                Donald Pipowitch,
                and Dave Finlay
                for their submissions and patches to the document.
            </t>
        </section>

        <section title="ChangeLog">
            <t>
                <cref>This section to be removed before leaving Internet-Draft status.</cref>
            </t>
            <t>
                <list style="hanging">
                    <t hangText="draft-handrews-json-schema-02">
                        <list style="symbols">
                            <t>Moved "definitions" from the Validation specification here as "$defs"</t>
                            <t>Moved applicator keywords from the Validation specification as their own vocabulary</t>
                            <t>Moved the schema form of "dependencies" from the Validation specification as "dependentSchemas"</t>
                        </list>
                    </t>
                    <t hangText="draft-handrews-json-schema-01">
                        <list style="symbols">
                            <t>This draft is purely a clarification with no functional changes</t>
                            <t>Emphasized annotations as a primary usage of JSON Schema</t>
                            <t>Clarified $id by use cases</t>
                            <t>Exhaustive schema identification examples</t>
                            <t>Replaced "external referencing" with how and when an implementation might know of a schema from another document</t>
                            <t>Replaced "internal referencing" with how an implementation should recognized schema identifiers during parsing</t>
                            <t>Dereferencing the former "internal" or "external" references is always the same process</t>
                            <t>Minor formatting improvements</t>
                        </list>
                    </t>
                    <t hangText="draft-handrews-json-schema-00">
                        <list style="symbols">
                            <t>Make the concept of a schema keyword vocabulary more clear</t>
                            <t>Note that the concept of "integer" is from a vocabulary, not the data model</t>
                            <t>Classify keywords as assertions or annotations and describe their general behavior</t>
                            <t>Explain the boolean schemas in terms of generalized assertions</t>
                            <t>Reserve "$comment" for non-user-visible notes about the schema</t>
                            <t>Wording improvements around "$id" and fragments</t>
                            <t>Note the challenges of extending meta-schemas with recursive references</t>
                            <t>Add "application/schema-instance+json" media type</t>
                            <t>Recommend a "schema" link relation / parameter instead of "profile"</t>
                        </list>
                    </t>
                    <t hangText="draft-wright-json-schema-01">
                        <list style="symbols">
                            <t>Updated intro</t>
                            <t>Allowed for any schema to be a boolean</t>
                            <t>"$schema" SHOULD NOT appear in subschemas, although that may change</t>
                            <t>Changed "id" to "$id"; all core keywords prefixed with "$"</t>
                            <t>Clarify and formalize fragments for application/schema+json</t>
                            <t>Note applicability to formats such as CBOR that can be represented in the JSON data model</t>
                        </list>
                    </t>
                    <t hangText="draft-wright-json-schema-00">
                        <list style="symbols">
                            <t>Updated references to JSON</t>
                            <t>Updated references to HTTP</t>
                            <t>Updated references to JSON Pointer</t>
                            <t>Behavior for "id" is now specified in terms of RFC3986</t>
                            <t>Aligned vocabulary usage for URIs with RFC3986</t>
                            <t>Removed reference to draft-pbryan-zyp-json-ref-03</t>
                            <t>Limited use of "$ref" to wherever a schema is expected</t>
                            <t>Added definition of the "JSON Schema data model"</t>
                            <t>Added additional security considerations</t>
                            <t>Defined use of subschema identifiers for "id"</t>
                            <t>Rewrote section on usage with HTTP</t>
                            <t>Rewrote section on usage with rel="describedBy" and rel="profile"</t>
                            <t>Fixed numerous invalid examples</t>
                        </list>
                    </t>
                    <t hangText="draft-zyp-json-schema-04">
                        <list style="symbols">
                            <t>Salvaged from draft v3.</t>
                            <t>Split validation keywords into separate document.</t>
                            <t>Split hypermedia keywords into separate document.</t>
                            <t>Initial post-split draft.</t>
                            <t>Mandate the use of JSON Reference, JSON Pointer.</t>
                            <t>Define the role of "id". Define URI resolution scope.</t>
                            <t>Add interoperability considerations.</t>
                        </list>
                    </t>
                    <t hangText="draft-zyp-json-schema-00">
                        <list style="symbols">
                            <t>Initial draft.</t>
                        </list>
                    </t>
                </list>
            </t>
        </section>
    </back>
</rfc>
