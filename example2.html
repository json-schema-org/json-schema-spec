<!DOCTYPE html>
<html>
<head>
    <title>Another JSON Schema example</title>
    <link href="lib/bootstrap-min.css" rel="stylesheet">
    <link rel="stylesheet" href="lib/json-highlight.css"></link>
</head>
<body>
<div class="container">
<div class="row">
    <div class="span8">
        <div class="page-header">
            <h1>JSON Schema example: fstab</h1>
        </div>
    </div>
</div>
<div class="row">
<div class="span8">
<h2>Purpose of the example</h2>

<p>This example shows a possible JSON representation of a hypothetical machine's mount points as
represented in an <tt>/etc/fstab</tt> file.</p>

<p>An entry in the fstab file can have many different forms. Here is a possible representation of a
full fstab:</p>

<pre class="json">
{
    "/": {
        "storage": {
            "type": "disk",
            "device": "/dev/sda1"
        },
        "fstype": "btrfs",
        "readonly": true
    },
    "/var": {
        "storage": {
            "type": "disk",
            "label": "8f3ba6f4-5c70-46ec-83af-0d5434953e5f"
        },
        "fstype": "ext4",
        "options": [ "nosuid" ]
    },
    "/tmp": {
        "storage": {
            "type": "tmpfs",
            "sizeInMB": 64
        }
    },
    "/var/www": {
        "storage": {
            "type": "nfs",
            "server": "my.nfs.server",
            "remotePath": "/exports/mypath"
        }
    }
}
</pre>

<p>Not all constraints to an fstab file can be modeled using JSON Schema alone; however, it can
already represent a good number of them. We will add constraints one after the other until we get to
a satisfactory result.</p>

<h2>Base schema</h2>

<p>We will start with a base schema expressing the following constraints:</p>

<ul>
<li>the list of entries is a JSON object;</li>
<li>the member names (or property names) of this object must all be valid, absolute paths;</li>
<li>there must be an entry for the root filesystem (ie, <tt>/</tt>).</li>
</ul>

<p>We also want the schema to be regarded as a draft v4 schema, we must therefore specify
<em>$schema</em>:</p>

<pre class="json-schema">
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "/": {}
    },
    "patternProperties": {
        "^(/[^/]+)+$": {}
    },
    "additionalProperties": false,
    "required": [ "/" ]
}
</pre>

<p>Note how the valid paths constraint is enforced here:</p>

<ul>
<li>we have a <em>properties</em> keyword with only a <tt>/</tt> entry;</li>
<li>we use <em>patternProperties</em> to match other property names via a regular
expression (note that it does not match <tt>/</tt>);</li>
<li>as <em>additionalProperties</em> is false, it constrains object properties to be either
<tt>/</tt> or to match the regular expression.</li>
</ul>

<p>You will notice that the regular expression is explicitly anchored: in JSON Schema, regular
expressions (in <em>patternProperties</em> and in <em>pattern</em>) are not anchored by default, you
must add anchors if you need them.</p>

<p>For now, the schemas describing individual entries are empty: we will start describing the
constraints in the following paragraphs, using another schema, which we will reference from the main
schema when we are ready.</p>

<h2>The entry schema</h2>

<h3>The skeleton</h3>

<p>Here again we will proceed little by little. We will start with the global structure of our
schema, which will be as such:</p>

<pre class="json-schema">
{
    "id": "http://some.site.somewhere/entry-schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "schema for an fstab entry",
    "type": "object",
    "required": [ "storage" ],
    "properties": {
        "storage": {
            "type": "object",
            "oneOf": [
                { "$ref": "#/definitions/diskDevice" },
                { "$ref": "#/definitions/diskUUID" },
                { "$ref": "#/definitions/nfs" },
                { "$ref": "#/definitions/tmpfs" }
            ]
        }
    },
    "definitions": {
        "diskDevice": {},
        "diskUUID": {},
        "nfs": {},
        "tmpfs": {}
    }
}
</pre>

<p>The expressed constraints you should already be familiar with: the JSON value must be an object, and this
object must have a property by the name <em>storage</em>; what is more, that <em>storage</em>
property must be an object. There are a couple of novelties:</p>

<ul>
<li>you will notice the appearance of JSON References, via the <em>$ref</em> keyword; here, all
references used are local to the schema, and the fragment part is a URI encoded JSON Pointer;</li>
<li>you will notice the appearance of an <em>id</em>: this is the URI of this resource; we assume
here that this URI is the actual URI of this schema;</li>
<li>the <em>oneOf</em> keyword is new; its argument is an array of schemas, and the data will be
valid if and only if it validates against only one of the schemas in the array;</li>
<li>finally, the <em>definitions</em> keyword is a standardized placeholder in which you can define
inline subschemas to be used in a schema.
</ul>

<h3>The <em>fstype</em>, <em>options</em> and <em>readonly</em> properties</h3>

<p>Let us now extend this skeleton to add constraints to the aforementioned properties. Note that
none of them is required:</p>

<ul>
<li>we only support <tt>ext3</tt>, <tt>ext4</tt> and <tt>btrfs</tt> as filesystem types;</li>
<li>the <em>options</em> array only allows strings; moreover, when specified, there must be at least
one option, and all options should be unique;</li>
<li><em>readonly</em> can only be a boolean.</li>
</ul>

<p>With these added constraints, the schema now looks like this:</p>

<pre class="json-schema">
{
    "id": "http://some.site.somewhere/entry-schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "schema for an fstab entry",
    "type": "object",
    "required": [ "storage" ],
    "properties": {
        "storage": {
            "type": "object",
            "oneOf": [
                { "$ref": "#/definitions/diskDevice" },
                { "$ref": "#/definitions/diskUUID" },
                { "$ref": "#/definitions/nfs" },
                { "$ref": "#/definitions/tmpfs" }
            ]
        },
        "fstype": {
            "enum": [ "ext3", "ext4", "btrfs" ]
        },
        "options": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "string" },
            "uniqueItems": true
        },
        "readonly": { "type": "boolean" }
    },
    "definitions": {
        "diskDevice": {},
        "diskUUID": {},
        "nfs": {},
        "tmpfs": {}
    }
}
</pre>

<p>It is now time we filled the different storage definitions.</p>

<h3>The <em>diskDevice</em> storage type</h3>

<p>This storage type has two required properties, <em>type</em> and <em>device</em>. The type can
only be <em>disk</em>, and the device must be an absolute path starting with <em>/dev</em>. No other
properties are allowed:</p>

<pre class="json-schema">
{
    "id": "http://some.site.somewhere/entry-schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "schema for an fstab entry",
    "type": "object",
    "required": [ "storage" ],
    "properties": {
        "storage": {
            "type": "object",
            "oneOf": [
                { "$ref": "#/definitions/diskDevice" },
                { "$ref": "#/definitions/diskUUID" },
                { "$ref": "#/definitions/nfs" },
                { "$ref": "#/definitions/tmpfs" }
            ]
        },
        "fstype": {
            "enum": [ "ext3", "ext4", "btrfs" ]
        },
        "options": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "string" },
            "uniqueItems": true
        },
        "readonly": { "type": "boolean" }
    },
    "definitions": {
        "diskDevice": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "device": {
                    "type": "string",
                    "pattern": "^/dev/[^/]+(/[^/]+)*$"
                }
            },
            "required": [ "type", "device" ],
            "additionalProperties": false
        },
        "diskUUID": {},
        "nfs": {},
        "tmpfs": {}
    }
}
</pre>

<h3>The <em>diskUUID</em> storage type</h3>

<p>This storage type has two required properties, <em>type</em> and <em>label</em>. The type can
only be <em>disk</em>, and the label must be a valid UUID. No other properties are allowed:</p>

<pre class="json-schema">
{
    "id": "http://some.site.somewhere/entry-schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "schema for an fstab entry",
    "type": "object",
    "required": [ "storage" ],
    "properties": {
        "storage": {
            "type": "object",
            "oneOf": [
                { "$ref": "#/definitions/diskDevice" },
                { "$ref": "#/definitions/diskUUID" },
                { "$ref": "#/definitions/nfs" },
                { "$ref": "#/definitions/tmpfs" }
            ]
        },
        "fstype": {
            "enum": [ "ext3", "ext4", "btrfs" ]
        },
        "options": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "string" },
            "uniqueItems": true
        },
        "readonly": { "type": "boolean" }
    },
    "definitions": {
        "diskDevice": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "device": {
                    "type": "string",
                    "pattern": "^/dev/[^/]+(/[^/]+)*$"
                }
            },
            "required": [ "type", "device" ],
            "additionalProperties": false
        },
        "diskUUID": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "label": {
                    "type": "string",
                    "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"
                }
            },
            "required": [ "type", "label" ],
            "additionalProperties": false
        },
        "nfs": {},
        "tmpfs": {}
    }
}
</pre>

<h3>The <em>nfs</em> storage type</h3>

<p>This storage type has three required properties: <em>type</em>, <em>server</em> and
<em>remotePath</em>. What is more, the server may be either a host name, an IPv4 address or an IPv6
address.</p>

<p>For the constraints on <em>server</em>, we use a new keyword: <em>format</em>. While it is not
required that <em>format</em> be supported, we will suppose that it is here:</p>

<pre class="json-schema">
{
    "id": "http://some.site.somewhere/entry-schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "schema for an fstab entry",
    "type": "object",
    "required": [ "storage" ],
    "properties": {
        "storage": {
            "type": "object",
            "oneOf": [
                { "$ref": "#/definitions/diskDevice" },
                { "$ref": "#/definitions/diskUUID" },
                { "$ref": "#/definitions/nfs" },
                { "$ref": "#/definitions/tmpfs" }
            ]
        },
        "fstype": {
            "enum": [ "ext3", "ext4", "btrfs" ]
        },
        "options": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "string" },
            "uniqueItems": true
        },
        "readonly": { "type": "boolean" }
    },
    "definitions": {
        "diskDevice": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "device": {
                    "type": "string",
                    "pattern": "^/dev/[^/]+(/[^/]+)*$"
                }
            },
            "required": [ "type", "device" ],
            "additionalProperties": false
        },
        "diskUUID": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "label": {
                    "type": "string",
                    "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"
                }
            },
            "required": [ "type", "label" ],
            "additionalProperties": false
        },
        "nfs": {
            "properties": {
                "type": { "enum": [ "nfs" ] },
                "remotePath": {
                    "type": "string",
                    "pattern": "^(/[^/]+)+$"
                },
                "server": {
                    "type": "string",
                    "oneOf": [
                        { "format": "host-name" },
                        { "format": "ipv4" },
                        { "format": "ipv6" }
                    ]
                }
            },
            "required": [ "type", "server", "remotePath" ],
            "additionalProperties": false
        },
        "tmpfs": {}
    }
}
</pre>

<h3> The <em>tmpfs</em> storage type</h3>

<p>This storage type has two required properties: <em>type</em> and <em>sizeInMB</em>. The size can
only be an integer. What is more, we will require that the size be between 16 and 512,
inclusive:</p>

<pre class="json-schema">
{
    "id": "http://some.site.somewhere/entry-schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "schema for an fstab entry",
    "type": "object",
    "required": [ "storage" ],
    "properties": {
        "storage": {
            "type": "object",
            "oneOf": [
                { "$ref": "#/definitions/diskDevice" },
                { "$ref": "#/definitions/diskUUID" },
                { "$ref": "#/definitions/nfs" },
                { "$ref": "#/definitions/tmpfs" }
            ]
        },
        "fstype": {
            "enum": [ "ext3", "ext4", "btrfs" ]
        },
        "options": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "string" },
            "uniqueItems": true
        },
        "readonly": { "type": "boolean" }
    },
    "definitions": {
        "diskDevice": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "device": {
                    "type": "string",
                    "pattern": "^/dev/[^/]+(/[^/]+)*$"
                }
            },
            "required": [ "type", "device" ],
            "additionalProperties": false
        },
        "diskUUID": {
            "properties": {
                "type": { "enum": [ "disk" ] },
                "label": {
                    "type": "string",
                    "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"
                }
            },
            "required": [ "type", "label" ],
            "additionalProperties": false
        },
        "nfs": {
            "properties": {
                "type": { "enum": [ "nfs" ] },
                "remotePath": {
                    "type": "string",
                    "pattern": "^(/[^/]+)+$"
                },
                "server": {
                    "type": "string",
                    "oneOf": [
                        { "format": "host-name" },
                        { "format": "ipv4" },
                        { "format": "ipv6" }
                    ]
                }
            },
            "required": [ "type", "server", "remotePath" ],
            "additionalProperties": false
        },
        "tmpfs": {
            "properties": {
                "type": { "enum": [ "tmpfs" ] },
                "sizeInMB": {
                    "type": "integer",
                    "minimum": 16,
                    "maximum": 512
                }
            },
            "required": [ "type", "sizeInMB" ],
            "additionalProperties": false
        }
    }
}
</pre>

<h2>Plugging this into our main schema</h2>

<p>Now that all possible entries have been described, we can refer to the entry schema from our main
schema. We will, again, use a JSON Reference here: </p>

<pre class="json-schema">
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "/": { "$ref": "http://some.site.somewhere/entry-schema#" }
    },
    "patternProperties": {
        "^(/[^/]+)+$": { "$ref": "http://some.site.somewhere/entry-schema#" }
    },
    "additionalProperties": false,
    "required": [ "/" ]
}
</pre>

<h2>Wrap up</h2>

<p>This example is much more advanced than the previous example; you will have learned of schema
referencing and identification, you will have been introduced to other keywords. It also raises some
interesting points.</p>

<h3>The schema can be improved</h3>

<p>For instance:</p>

<ul>
<li>it makes no sense for <tt>/</tt> to be mounted on a tmpfs filesystem;</li>
<li>it makes no sense to specify the filesystem type if the storage is either NFS or tmpfs.</li>
</ul>

<p>As an exercise, you can always try and add these constraints. It would probably require splitting
the schema further.</p>

<h3>JSON Schema limits itself to structural validation</h3>

<p>The <em>format</em> keyword is the only exception to this (with it, you can do semantic
validation of primitive types, such as strings), but supporting it is not required.</p>

<p>What is more, if we take an NFS entry as an example, it would be the role of your application
code to check that the submitted NFS server's hostname, or IP address, is actually correct.</p>

</div>
</div>
</div>

<script src="lib/json-highlight.js"></script>
</body>
</html>
