<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc2046 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!--<!ENTITY rfc4287 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">-->
<!--<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">-->
<!ENTITY rfc5988 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml">
<!ENTITY rfc6570 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6570.xml">
<!ENTITY rfc7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY html5 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-html5-20140731.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes" ?>
<rfc category="info" docName="draft-wright-json-schema-hyperschema-00" ipr="trust200902">
    <front>
        <title abbrev="JSON Hyper-Schema">JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON</title>

        <author fullname="Austin Wright" initials="A" surname="Wright" role="editor">
            <address>
                <email>aaa@bzfx.net</email>
            </address>
        </author>

        <author fullname="Geraint Luff" initials="G" surname="Luff">
            <address>
                <postal>
                    <street></street>
                    <city>Cambridge</city>
                    <country>UK</country>
                </postal>
                <email>luffgd@gmail.com</email>
            </address>
        </author>

        <date year="2016" />
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>JavaScript</keyword>
        <keyword>Object</keyword>
        <keyword>Notation</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema is a JSON based format for defining the structure of JSON data.
                This document specifies hyperlink- and hypermedia-related keywords of JSON Schema for
                annotating JSON documents with hyperlinks and instructions for processing and manipulating remote JSON resources
                through hypermedia environments like HTTP.
            </t>
        </abstract>
        <note title="Note to Readers">
            <t>
                The issues list for this draft can be found at <eref target="https://github.com/json-schema-org/json-schema-spec/issues"/>.
            </t>
            <t>
                For additional information, see <eref target="http://json-schema.org/"/>.
            </t>
            <t>
                To provide feedback, use this issue tracker, the communication methods listed on the homepage, or email the document editors.
            </t>
        </note>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Schema is a JSON based format for defining the structure of JSON data.
                This document specifies hyperlink- and hypermedia-related keywords of JSON Schema.
            </t>
            <t>
                The term JSON Hyper-Schema is used to refer to a JSON Schema that uses these keywords.
            </t>

            <t>
                This specification will use the terminology defined by the <xref target="json-schema">JSON Schema core
                specification</xref>.
                It is advised that readers have a copy of this specification.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "schema", "instance", "property" and "item" are to be interpreted as defined in the <xref target="json-schema">JSON Schema core
                specification</xref>.
            </t>
        </section>

        <section title="Overview">
            <t>
                This document describes how JSON Schema can be used to define hyperlinks on instance data.
                It also defines how to provide additional information required to interpret JSON data as rich multimedia documents.
            </t>
            <t>
                As with all JSON Schema keywords, all the keywords described in the "Schema Keywords" section are optional. The minimal valid JSON Hyper-schema is the blank object.
            </t>
            <figure>
                <preamble>Here is an example JSON Schema defining hyperlinks, and providing a multimedia interpretation for the "imgData" property:</preamble>
                <artwork>
<![CDATA[
{
    "title": "Written Article",
    "type": "object",
    "properties": {
        "id": {
            "title": "Article Identifier",
            "type": "number",
            "readOnly": true
        },
        "title": {
            "title": "Article Title",
            "type": "string"
        },
        "authorId": {
            "type": "integer"
        },
        "imgDataPng": {
            "title": "Article Illustration (thumbnail)",
            "type": "string",
            "media": {
                "binaryEncoding": "base64",
                "type": "image/png"
            }
        }
    },
    "required" : ["id", "title", "authorId"],
    "links": [
        {
            "rel": "self",
            "href": "/article{?id}"
        },
        {
            "rel": "author",
            "href": "/user?id={authorId}"
        }
    ]
}
]]>
                </artwork>
                <postamble>
                    This example schema defines the properties of the instance.
                    For the "imgData" property, it specifies that that it should be base64-decoded and the resulting binary data treated as a PNG image.
                    It also defines link relations for the instance, with URIs incorporating values from the instance.
                    <cref>"id" probably should not normally be a required keyword, since new instances will have an unknown "id" property until is it assigned by the server. However, this property is used in a link, and without it, multiple different instances would be given the same rel=self URI!</cref>
                </postamble>
            </figure>

            <figure>
                <preamble>An example of a JSON instance described by the above schema might be:</preamble>
                <artwork>
<![CDATA[
{
    "id": 15,
    "title": "Example data",
    "authorId": 105,
    "imgData": "iVBORw...kJggg=="
}
]]>
                </artwork>
                <postamble>The base-64 data has been abbreviated for readability.</postamble>
            </figure>

        </section>

        <section title="Schema keywords">
            <section title="base">
                <t>
                    If present, this keyword is resolved against the current URI base that the entire instance is found within, and sets the new URI base for URI references within the instance.
                    It is therefore the first URI Reference resolved, regardless of which order it was found in.
                </t>
                <t>
                    The URI is computed from the provided URI template using the same process described for the <xref target="href">"href"</xref> property of a Link Description Object.
                </t>
                <figure>
                    <preamble>An example of a JSON schema using "base":</preamble>
                    <artwork>
<![CDATA[
{
    "base": "/object/{id}",
    "links": [
        {
            "rel": "self",
            "href": ""
        },
        {
            "rel": "next",
            "href": "{next_id}"
        }
    ]
}
]]>
                    </artwork>
                </figure>
                <figure>
                    <preamble>An example of a JSON instance using this schema to produce rel="self" and rel="next" links:</preamble>
                    <artwork>
<![CDATA[
{
    "id": "41",
    "next_id": "42"
}
]]>
                    </artwork>
                </figure>
                <t>
                    If the document URI is &lt;http://example.com/?id=41&gt;, then the new URI base becomes &lt;http://example.com/object/41&gt;
                </t>
                <t>
                    Resolving the two Link Description Objects against this URI base creates two links exactly equivelant to these absolute-form HTTP Link headers:
                    <list style="symbols">
                        <t>Link: &lt;http://example.com/object/41&gt;;rel=self</t>
                        <t>Link: &lt;http://example.com/object/42&gt;;rel=next</t>
                    </list>
                </t>
            </section>

            <section title="links">
                <t>
                    The "links" property of schemas is used to associate Link Description Objects with instances.  The value of this property MUST be an array, and the items in the array must be Link Description Objects, as defined below.
                </t>

                <figure>
                    <preamble>An example schema using the "links" keyword could be:</preamble>
                    <artwork>
<![CDATA[{
    "title": "Schema defining links",
    "links": [
        {
            "rel": "self",
            "href": "{id}"
        },
        {
            "rel": "parent",
            "href": "{parent}"
        }
    ]
}]]>
                    </artwork>
                </figure>
            </section>

            <section title="media">
                <t>
                    The "media" property indicates that this instance contains non-JSON data encoded in a JSON string.
                    It describes the type of content and how it is encoded.
                </t>
                <t>
                    The value of this property MUST be an object.
                    The value of this property SHOULD be ignored if the instance described is not a string.
                </t>

                <section title="Properties of &quot;media&quot;">
                    <t>
                        The value of the "media" keyword MAY contain any of the following properties:
                    </t>

                    <section title="binaryEncoding">
                        <t>
                            If the instance value is a string, this property defines that the string SHOULD be interpreted as binary data and decoded using the encoding named by this property.
                            <xref target="RFC2045">RFC 2045, Sec 6.1</xref> lists the possible values for this property.
                        </t>
                    </section>

                    <section title="type">
                        <t>
                            The value of this property must be a media type, as defined by <xref target="RFC2046">RFC 2046</xref>.
                            This property defines the media type of instances which this schema defines.
                        </t>

                        <t>
                            If the "binaryEncoding" property is not set, but the instance value is a string, then the value of this property SHOULD specify a text document type, and the character set SHOULD be the character set into which the JSON string value was decoded (for which the default is Unicode).
                        </t>
                    </section>
                </section>

                <section title="Example">
                    <figure>
                        <preamble>Here is an example schema, illustrating the use of "media":</preamble>
                        <artwork>
<![CDATA[
{
    "type": "string",
    "media": {
        "binaryEncoding": "base64",
        "type": "image/png"
    }
}
]]>
                        </artwork>
                        <postamble>Instances described by this schema should be strings, and their values should be interpretable as base64-encoded PNG images.</postamble>
                    </figure>

                    <figure>
                        <preamble>Another example:</preamble>
                        <artwork>
<![CDATA[
{
    "type": "string",
    "media": {
        "mediaType": "text/html"
    }
}
]]>
                        </artwork>
                        <postamble>Instances described by this schema should be strings containing HTML, using whatever character set the JSON string was decoded into (default is Unicode).</postamble>
                    </figure>
                </section>
            </section>

            <section title="readOnly">
                <t>
                    If it has a value of boolean true, this keyword indicates that the value of the instance is managed exclusively by the server or the owning authority, and attempts by a user agent to modify the value of this property are expected to be ignored or rejected by a server.
                </t>
                <t>
                    For example, this property would be used to mark a server-generated serial number as read-only.
                </t>
                <t>
                    The value of this keyword MUST be a boolean.
                    The default value is false.
                </t>
            </section>
        </section>

        <section title="Link Description Object">
            <t>
                A Link Description Object (LDO) is used to describe a single link relation from the instance to another resource.
                A Link Description Object must be an object.
            </t>

            <t>
                The link description format can be used without JSON Schema, and use of this format can be declared by referencing the normative link description schema as the schema for the data structure that uses the links.
                The URI of the normative link description schema is: <eref target="http://json-schema.org/draft-04/links">http://json-schema.org/draft-04/links</eref> (draft-04 version).
            </t>

            <t>
                "Form"-like functionality can be defined by use of the "method" and "schema" keywords, which supplies a schema describing the data to supply to the server.
            </t>

            <section title="href" anchor="href">
                <t>
                    The value of the "href" link description property is a template used to determine the target URI of the related resource.
                    The value of the instance property MUST be resolved as a <xref target="RFC3986">URI-reference</xref> against the base URI of the instance.
                </t>
                <t>
                    This property is REQUIRED.
                </t>

                <section title="URI Templating">
                    <t>
                        The value of "href" is to be used as a URI Template, as defined in <xref target="RFC6570">RFC 6570</xref>.  However, some special considerations apply:
                    </t>

                    <section title="Pre-processing">
                        <t>
                            <cref>This pre-processing section is subject to significant change in upcoming drafts.</cref>
                        </t>
                        <t>
                            The <xref target="RFC6570">URI Template specification</xref> restricts the set of characters available for variable names.
                            Property names in JSON, however, can be any UTF-8 string.
                        </t>

                        <t>
                            To allow the use of any JSON property name in the template, before using the value of "href" as a URI Template, the following pre-processing rules MUST be applied, in order:
                        </t>

                        <section title="Bracket escaping">
                            <t>
                                The purpose of this step is to allow the use of brackets to percent-encode variable names inside curly brackets.
                                Variable names to be escaped are enclosed within rounded brackets, with the close-rounded-bracket character ")" being escaped as a pair of close-rounded-brackets "))".
                                Since the empty string is not a valid variable name in RFC 6570, an empty pair of brackets is replaced with "%65mpty".
                            </t>

                            <t>
                                The rules are as follows:
                            </t>

                            <t>
                                Find the largest possible sections of the text such that:
                                <list>
                                    <t>do not contain an odd number of close-rounded-bracket characters ")" in sequence in that section of the text</t>
                                    <t>are surrounded by a pair of rounded brackets: ( ), where</t>
                                    <t>the surrounding rounded brackets are themselves contained within a pair of curly brackets: { }</t>
                                </list>
                            </t>
                            <t>
                                Each of these sections of the text (including the surrounding rounded brackets) MUST be replaced, according to the following rules:
                                <list>
                                    <t>If the brackets contained no text (the empty string), then they are replaced with "%65mpty" (which is "empty" with a percent-encoded "e")</t>
                                    <t>Otherwise, the enclosing brackets are removed, and the inner text used after the following modifications
                                        <list>
                                            <t>all pairs of close-brackets "))" are replaced with a single close bracket</t>
                                            <t>after that, the text is replaced with its percent-encoded equivalent, such that the result is a valid RFC 6570 variable name (note that this requires encoding characters such as "*" and "!")</t>
                                        </list>
                                    </t>
                                </list>
                            </t>
                        </section>

                        <section title="Replacing $">
                            <t>
                                After the above substitutions, if the character "$" (dollar sign) appears within a pair of curly brackets, then it MUST be replaced with the text "%73elf" (which is "self" with a percent-encoded "s").
                            </t>
                            <t>
                                The purpose of this stage is to allow the use of the instance value itself (instead of its object properties or array items) in the URI Template, by the special value "%73elf".
                            </t>
                        </section>

                        <section title="Choice of special-case values">
                            <t>
                                The special-case values of "%73elf" and "%65mpty" were chosen because they are unlikely to be accidentally generated by either a human or automated escaping.
                            </t>
                        </section>

                        <section title="Examples">
                            <texttable>
                                <preamble>For example, here are some possible values for "href", followed by the results after pre-processing:</preamble>
                                <ttcol>Input</ttcol>
                                <ttcol>Output</ttcol>
                                <c>"no change"</c>           <c>"no change"</c>
                                <c>"(no change)"</c>         <c>"(no change)"</c>
                                <c>"{(escape space)}"</c>    <c>"{escape%20space}"</c>
                                <c>"{(escape+plus)}"</c>     <c>"{escape%2Bplus}"</c>
                                <c>"{(escape*asterisk)}"</c> <c>"{escape%2Aasterisk}"</c>
                                <c>"{(escape(bracket)}"</c>  <c>"{escape%28bracket}"</c>
                                <c>"{(escape))bracket)}"</c> <c>"{escape%29bracket}"</c>
                                <c>"{(a))b)}"</c>            <c>"{a%29b}</c>
                                <c>"{(a (b)))}"</c>          <c>"{a%20%28b%29}</c>
                                <c>"{()}"</c>                <c>"{%65mpty}</c>
                                <c>"{+$*}"</c>               <c>"{+%73elf*}</c>
                                <c>"{+($)*}"</c>             <c>"{+%24*}</c>
                                <postamble>
                                    Note that in the final example, because the "+" was outside the brackets, it remained unescaped, whereas in the fourth example the "+" was escaped.
                                </postamble>
                            </texttable>
                        </section>
                    </section>

                    <section title="Values for substitution">
                        <t>
                            After pre-processing, the URI Template is filled out using data from the instance.
                            To allow the use of any object property (including the empty string), array index, or the instance value itself, the following rules are defined:
                        </t>

                        <t>
                            For a given variable name in the URI Template, the value to use is determined as follows:
                            <list>
                                <t>If the variable name is "%73elf", then the instance value itself MUST be used.</t>
                                <t>If the variable name is "%65mpty", then the instances's empty-string ("") property MUST be used (if it exists).</t>
                                <t>If the instance is an array, and the variable name is a representation of a non-negative integer, then the value at the corresponding array index MUST be used (if it exists).</t>
                                <t>Otherwise, the variable name should be percent-decoded, and the corresponding object property MUST be used (if it exists).</t>
                            </list>
                        </t>

                        <section title="Converting to strings">
                            <t>
                                When any value referenced by the URI template is null, a boolean or a number, then it should first be converted into a string as follows:
                                <list>
                                    <t>null values SHOULD be replaced by the text "null"</t>
                                    <t>boolean values SHOULD be replaced by their lower-case equivalents: "true" or "false"</t>
                                    <t>numbers SHOULD be replaced with their original JSON representation.</t>
                                </list>
                            </t>
                            <t>
                                In some software environments the original JSON representation of a number will not be available (there is no way to tell the difference between 1.0 and 1), so any reasonable representation should be used.
                                Schema and API authors should bear this in mind, and use other types (such as string or boolean) if the exact representation is important.
                            </t>
                        </section>
                    </section>

                    <section title="Missing values">
                        <t>
                            Sometimes, the appropriate values will not be available.
                            For example, the template might specify the use of object properties, but the instance is an array or a string.
                        </t>

                        <t>
                            If any of the values required for the template are not present in the JSON instance, then substitute values MAY be provided from another source (such as default values).
                            Otherwise, the link definition SHOULD be considered not to apply to the instance.
                        </t>
                    </section>
                </section>

            </section>

            <section title="rel">
                <t>
                    The value of the "rel" property indicates the name of the relation to the target resource. The value MUST be a registered link relation from the <xref target="RFC5988">IANA Link Relation Type Registry established in RFC 5988</xref>, or a normalized URI following the <xref target="RFC3986">URI production of RFC 3986</xref>.
                </t>

                <t>
                    The relation to the target is interpreted as from the instance that the schema (or sub-schema) applies to, not any larger document that the instance may have been found in.
                </t>

                <t>
                    Relationship definitions are not normally media type dependent, and users are encouraged to utilize existing accepted relation definitions.
                </t>

                <figure>
                    <preamble>For example, if a schema is defined:</preamble>
                    <artwork>
<![CDATA[{
    "links": [{
        "rel": "self",
        "href": "{id}"
    }, {
        "rel": "up",
        "href": "{upId}"
    }]
}]]>
                    </artwork>
                </figure>

                <figure>
                    <preamble>And if a collection of instance resources were retrieved with JSON representation:</preamble>
                    <artwork>
<![CDATA[GET /Resource/

[{
    "id": "thing",
    "upId": "parent"
}, {
    "id": "thing2",
    "upId": "parent"
}]]]>
                    </artwork>
                    <postamble>
                        This would indicate that for the first item in the collection, its own (self) URI would resolve to "/Resource/thing" and the first item's "up" relation SHOULD be resolved to the resource at "/Resource/parent".
                    </postamble>
                </figure>

                <t>
                    Note that these relationship values are case-insensitive, consistent with their use in HTML and the <xref target="RFC5988">HTTP Link header</xref>.
                </t>

                <section title="Security Considerations for &quot;self&quot; links">
                    <t>
                        When link relation of "self" is used to denote a full representation of an object, the user agent SHOULD NOT consider the representation to be the authoritative representation of the resource denoted by the target URI if the target URI is not equivalent to or a sub-path of the the URI used to request the resource representation which contains the target URI with the "self" link.

                        <figure>
                            <preamble>For example, if a hyper schema was defined:</preamble>
                            <artwork>
<![CDATA[{
    "links": [{
        "rel": "self",
        "href": "{id}"
    }]
}]]>
                            </artwork>
                        </figure>

                        <figure>
                            <preamble>And a resource was requested from somesite.com:</preamble>
                            <artwork>
<![CDATA[
GET /foo/
]]>
                            </artwork>
                        </figure>

                        <figure>
                            <preamble>With a response of (with newlines and whitespace added):</preamble>
                            <artwork>
<![CDATA[Content-Type: application/json; profile="http://example.com/alpha"

[{
    "id": "bar",
    "name": "This representation can be safely treated
             as authoritative "
}, {
    "id": "/baz",
    "name": "This representation should not be treated as
             authoritative the user agent should make request the
             resource from '/baz' to ensure it has the authoritative
             representation"
}, {
    "id": "http://othersite.com/something",
    "name": "This representation
             should also not be treated as authoritative and the
             target resource representation should be retrieved
             for the authoritative representation"
}]]]>
                            </artwork>
                        </figure>
                    </t>
                </section>
            </section>

            <section title="title">
                <t>
                    This property defines a title for the link.
                    The value must be a string.
                </t>

                <t>
                    User agents MAY use this title when presenting the link to the user.
                </t>
            </section>

            <section title="targetSchema">
                <t>
                    This property provides a schema that is expected to describe the link target, including what a client can expect if it makes an HTTP GET request, and what it should send if it replaces the resource in an HTTP PUT request. This property is advisory only.
                </t>

                <section title="Security Considerations for &quot;targetSchema&quot;">
                    <t>
                        This property has similar security concerns to that of "mediaType".
                        Clients MUST NOT use the value of this property to aid in the interpretation of the data received in response to following the link, as this leaves "safe" data open to re-interpretation.
                    </t>
                    <t>
                        <figure>
                            <preamble>
                                For example, suppose two programmers are having a discussion about web security using a text-only message board.
                                Here is some data from that conversation, with a URI of: http://forum.example.com/topics/152/comments/13
                            </preamble>
                            <artwork>
<![CDATA[{
    "topicId": 152,
    "commentId": 13,
    "from": {
        "name": "Jane",
        "id": 5
    },
    "to": {
        "name": "Jason",
        "id": 8
    },
    "message": "It's easy, just add some HTML like
         this: <script>doSomethingEvil()</script>"
}]]>
                            </artwork>
                            <postamble>
                                The message string was split over two lines for readability.
                            </postamble>
                        </figure>
                    </t>
                    <t>
                        A third party might then write provide the following Link Description Object at another location:
                        <figure>
                            <artwork>
<![CDATA[{
    "rel": "evil-attack",
    "href": "http://forum.example.com/topics/152/comments/13",
    "targetSchema": {
        "properties": {
            "message": {
                "description": "Re-interpret `message` as HTML",
                "media": {
                    "type": "text/html"
                }
            }
        }
    }
}]]>
                            </artwork>
                            <postamble>
                                If the client used this "targetSchema" value when interpreting the above data, then it might display the contents of "message" as HTML.
                                At this point, the JavaScript embedded in the message might be executed (in the context of the "forum.example.com" domain).
                            </postamble>
                        </figure>
                    </t>
                </section>
            </section>

            <section title="mediaType">
                <t>
                    The value of this property is advisory only, and represents the media type <xref target="RFC2046">RFC 2046</xref>, that is expected to be returned when fetching this resource.
                    This property value MAY be a media range instead, using the same pattern defined in <xref target="RFC7231">RFC 7231, section 5.3.1 - HTTP "Accept" header</xref>.
                </t>

                <t>
                    This property is analogous to the "type" property of &lt;a&gt; elements in HTML (advisory content type), or the "type" parameter in the <xref target="RFC5988">HTTP Link header</xref>.
                    User agents MAY use this information to inform the interface they present to the user before the link is followed, but this information MUST NOT use this information in the interpretation of the resulting data.
                    When deciding how to interpret data obtained through following this link, the behaviour of user agents MUST be identical regardless of the value of the this property.
                </t>

                <t>
                    If this property's value is specified, and the link's target is to be obtained using any protocol that supports the HTTP/1.1 "Accept" header <xref target="RFC7231">RFC 7231, section 5.3.1</xref>, then user agents MAY use the value of this property to aid in the assembly of that header when making the request to the server.
                </t>

                <t>
                    If this property's value is not specified, then the value should be taken to be "application/json".
                </t>

                <figure>
                    <preamble>For example, if a schema is defined:</preamble>
                    <artwork>
<![CDATA[
{
    "links": [{
        "rel": "self",
        "href": "/{id}/json"
    }, {
        "rel": "alternate",
        "href": "/{id}/html",
        "mediaType": "text/html"
    }, {
        "rel": "alternate",
        "href": "/{id}/rss",
        "mediaType": "application/rss+xml"
    }, {
        "rel": "icon",
        "href": "{id}/icon",
        "mediaType": "image/*"
    }]
}
]]>
                    </artwork>
                    <postamble>
                        A suitable instance described by this schema would have four links defined.
                        The link with a "rel" value of "self" would have an expected MIME type of "application/json" (the default).
                        The two links with a "rel" value of "alternate" specify the locations of HTML and RSS versions of the current item.
                        The link with a "rel" value of "icon" links to an image, but does not specify the exact format.
                    </postamble>
                </figure>

                <t>
                    A visual user agent displaying the item from the above example might present a button representing an RSS feed, which when pressed passes the target URI (calculated "href" value) to an view more suited to displaying it, such as a news feed aggregator tab.
                </t>

                <t>
                    Note that presenting the link in the above manner, or passing the URI to a news feed aggregator view does not constitute interpretation of the data, but an interpretation of the link.
                    The interpretation of the data itself is performed by the news feed aggregator, which SHOULD reject any data that would not have also been interpreted as a news feed, had it been displayed in the main view.
                </t>

                <section title="Security concerns for &quot;mediaType&quot;">
                    <t>
                        The "mediaType" property in link definitions defines the expected format of the link's target.
                        However, this is advisory only, and MUST NOT be considered authoritative.
                    </t>

                    <t>
                        When choosing how to interpret data, the type information provided by the server (or inferred from the filename, or any other usual method) MUST be the only consideration, and the "mediaType" property of the link MUST NOT be used.
                        User agents MAY use this information to determine how they represent the link or where to display it (for example hover-text, opening in a new tab).
                        If user agents decide to pass the link to an external program, they SHOULD first verify that the data is of a type that would normally be passed to that external program.
                    </t>

                    <t>
                        This is to guard against re-interpretation of "safe" data, similar to the precautions for "targetSchema".
                    </t>
                </section>
            </section>

            <section title="Submission Form Properties">
                <t>
                    The following properties also apply to Link Description Objects, and provide functionality analogous to <xref target="W3C.CR-html5-20140731">HTMLforms</xref>, by providing a means for making a request with client- or user-selected information.
                </t>

                <section title="method">
                    <t>
                        This property specifies that the client can construct a templated query or non-idempotent request to a resource.
                    </t>
                    <t>
                        If "method" is "get", the link identifies how a user can compute the URI of an arbritrary resource. For example, how compute a link to a page of search results relating to the instance, for a user-selected query term. Despite being named after GET, there is no constraint on the method or protocol used to interact with the remote resource.
                    </t>
                    <t>
                        If "method" is "post", the link specifies how a user can construct a document to submit to the link target for evaluation.
                    </t>
                    <t>
                        Values for this property SHOULD be lowercase, and SHOULD be compared case-insensitive. Use of other values not defined here SHOULD be ignored.
                    </t>
                </section>

                <section title="encType">
                    <t>
                        If present, this property indicates the media type format the client should use to encode a query parameter or send to the server. posting to the collection of instances at the target resource.
                        If the method is "get", this will indicate how to encode the query-string that is appended to the "href" link target.
                        If the method is "post", this indicates which media type to send to the server and how to encode it.

                        <figure>
                            <preamble>For example, with the following schema:</preamble>
                            <artwork>
<![CDATA[{
    "links": [{
        "encType": "application/x-www-form-urlencoded",
        "method": "get",
        "href": "/Product/",
        "properties": {
            "name": {
                "description": "name of the product"
            }
        }
    }]
}]]>
                            </artwork>
                            <postamble>This indicates that the client can query the server for instances that have a specific name.</postamble>
                        </figure>

                        <figure>
                            <preamble>For example:</preamble>
                            <artwork>
<![CDATA[
/Product/?name=Slinky
]]>
                            </artwork>
                        </figure>

                        If the method is "post", "application/json" is the default media type.
                    </t>
                </section>

                <section title="schema">
                    <t>
                        This property contains a schema which defines the acceptable structure of the document being encoded according to the "encType" property.
                    </t>

                    <t>
                        Note that this does not provide data for any URI templates.
                        This is a separate concept from the "targetSchema" property, which is describing the target information resource (including for replacing the contents of the resource in a PUT request), unlike "schema" which describes the user-submitted request data to be evaluated by the resource.
                    </t>
                </section>
            </section>
        </section>

<!--
        <section title="IANA Considerations">
            <t>No considerations</t>
        </section>
-->
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &rfc2045;
            &rfc2119;
            &rfc3986;
            <!--&rfc4287;-->
            &rfc6570;
            <reference anchor="json-schema">
                <front>
                    <title>JSON Schema: A Media Type for Describing JSON Documents</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <date year="2016" month="October"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-wright-json-schema-00" />
            </reference>
        </references>
        <references title="Informative References">
            &rfc2046;
            <!--&rfc5226;-->
            &rfc5988;
            &rfc7231;
            &html5;
        </references>

        <section title="Acknowledgments">
            <t>
                Thanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.
            </t>
            <t>
                Thanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Ben Hutton,
                Evgeny Poberezkin,
                and Henry H. Andrews
                for their submissions and patches to the document.
            </t>
        </section>

        <section title="Change Log">
            <t>
                <cref>This section to be removed before leaving Internet-Draft status.</cref>
            </t>
            <t>
                <list style="hanging">
                    <t hangText="draft-wright-json-schema-hyperschema-00">
                        <list style="symbols">
                            <t>"rel" is now optional</t>
                            <t>rel="self" no longer changes URI base</t>
                            <t>Added "base" keyword to change instance URI base</t>
                            <t>Removed "root" link relation</t>
                            <t>Removed "create" link relation</t>
                            <t>Removed "full" link relation</t>
                            <t>Removed "instances" link relation</t>
                            <t>Removed special behavior for "describedBy" link relation</t>
                            <t>Removed "pathStart" keyword</t>
                            <t>Removed "fragmentResolution" keyword</t>
                            <t>Updated references to JSON Pointer, HTML</t>
                            <t>Changed behavior of "method" property to align with hypermedia best current practices</t>
                        </list>
                    </t>
                    <t hangText="draft-luff-json-hyper-schema-01">
                        <list style="symbols">
                            <t>Split from main specification.</t>
                        </list>
                    </t>
                </list>
            </t>
        </section>
    </back>
</rfc>
