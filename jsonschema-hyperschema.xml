<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2046 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc4151 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4151.xml">
<!--<!ENTITY rfc4287 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">-->
<!--<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">-->
<!ENTITY rfc5789 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5789.xml">
<!ENTITY rfc5988 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml">
<!ENTITY rfc6570 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6570.xml">
<!ENTITY rfc6901 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6901.xml">
<!ENTITY rfc7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY rfc7240 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7240.xml">
<!ENTITY I-D.luff-relative-json-pointer SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-luff-relative-json-pointer-00.xml">
<!ENTITY I-D.reschke-http-jfv SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-reschke-http-jfv-06.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes" ?>
<rfc category="info" docName="draft-wright-json-schema-hyperschema-02" ipr="trust200902">
    <front>
        <title abbrev="JSON Hyper-Schema">
            JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON
        </title>

        <author fullname="Austin Wright" initials="A" surname="Wright" role="editor">
            <address>
                <email>aaa@bzfx.net</email>
            </address>
        </author>

        <author fullname="Henry Andrews" initials="H" surname="Andrews" role="editor">
            <organization>Cloudflare, Inc.</organization>
            <address>
                <email>henry@cloudflare.com</email>
            </address>
        </author>

        <author fullname="Geraint Luff" initials="G" surname="Luff">
            <address>
                <postal>
                    <street></street>
                    <city>Cambridge</city>
                    <country>UK</country>
                </postal>
                <email>luffgd@gmail.com</email>
            </address>
        </author>

        <date year="2017" />
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>JavaScript</keyword>
        <keyword>Object</keyword>
        <keyword>Notation</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema is a JSON based format for defining the structure of JSON data.
                This document specifies hyperlink- and hypermedia-related keywords of JSON Schema
                for annotating JSON documents with hyperlinks and instructions for processing and
                manipulating remote JSON resources through hypermedia environments like HTTP.
            </t>
        </abstract>
        <note title="Note to Readers">
            <t>
                The issues list for this draft can be found at
                <eref target="https://github.com/json-schema-org/json-schema-spec/issues"/>.
            </t>
            <t>
                For additional information, see
                <eref target="http://json-schema.org/"/>.
            </t>
            <t>
                To provide feedback, use this issue tracker, the communication methods listed on the
                homepage, or email the document editors.
            </t>
        </note>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Schema is a JSON based format for defining the structure of JSON data.
                This document specifies hyperlink- and hypermedia-related keywords of JSON Schema.
            </t>
            <t>
                The term JSON Hyper-Schema is used to refer to a JSON Schema that uses these
                keywords.
            </t>

            <t>
                This specification will use the concepts, syntax, and terminology defined by the
                <xref target="json-schema">JSON Schema core</xref> and
                <xref target="json-schema-validation">JSON Schema validation</xref> specifications.
                It is advised that readers have a copy of these specifications.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "schema" and "instance" are to be interpreted as defined in the
                <xref target="json-schema">JSON Schema core specification</xref>.
            </t>
        </section>

        <section title="Overview">
            <t>
                This document describes how JSON Schema can be used to define hyperlinks on instance
                data.
            </t>
            <t>
                As with all JSON Schema keywords, all the keywords described in the "Schema
                Keywords" section are optional. The minimal valid JSON Hyper-schema is the blank
                object.
            </t>
            <figure>
                <preamble>
                    Here is an example JSON Schema defining hyperlinks:
                </preamble>
                <artwork>
<![CDATA[
{
    "title": "Written Article",
    "type": "object",
    "properties": {
        "id": {
            "title": "Article Identifier",
            "type": "number",
            "readOnly": true
        },
        "title": {
            "title": "Article Title",
            "type": "string"
        },
        "authorId": {
            "type": "integer"
        }
    },
    "required" : ["id", "title", "authorId"],
    "links": [
        {
            "rel": "self",
            "href": "/article{?id}"
        },
        {
            "rel": "author",
            "href": "/user?id={authorId}"
        }
    ]
}
]]>
                </artwork>
                <postamble>
                    This example schema defines the properties of the instance as well as link
                    relations for the instance, with URIs incorporating values from the instance.
                    <cref>
                        "id" probably should not normally be a required keyword, since new instances
                        will have an unknown "id" property until is it assigned by the server.
                        However, this property is used in a link, and without it, multiple different
                        instances would be given the same rel=self URI!
                    </cref>
                </postamble>
            </figure>

            <section title="Interaction with validation">
                <t>
                    Hyper-schema keywords can be applied when the instance is valid against
                    the schema that includes those keywords.
                </t>
                <t>
                    Hyper-schemas MUST NOT be applied to an instance if the instance fails to
                    validate against the validation keywords within or containing the hyper-schema.
                    Hyper-schema keywords in branches of an "anyOf", "oneOf", or "if"/"then"/"else"
                    that do not validate, or in a "dependencies" subschema that is not relevant
                    to the instance, MUST be ignored.
                </t>
                <t>
                    Hyper-schema keywords in a subschema contained within a "not", at any depth,
                    including any number of intervening additional "not" subschemas, MUST be
                    ignored.
                </t>
                <t>
                    If the subschema for a "contains" keyword contains hyper-schema keywords they
                    MUST be applied to all array elements that validate against the schema.  While
                    finding a single validating element is sufficient to determine the validation
                    outcome, when hyper-schema keywords are present, the subschema MUST be evaluated
                    against all array elements.
                </t>
            </section>
        </section>

        <section title="Meta-schema">
            <t>
                The current URI for the JSON Hyper-Schema meta-schema is
                &lt;http://json-schema.org/draft-06/hyper-schema#&gt;.
            </t>
        </section>

        <section title="Schema keywords">
            <section title="base">
                <t>
                    If present, this keyword is resolved against the current URI base that the
                    entire instance is found within, and sets the new URI base for URI references
                    within the instance.
                    It is therefore the first URI Reference resolved, regardless of which order it
                    was found in.
                </t>
                <t>
                    The URI is computed from the provided URI template using the same process
                    described for the <xref target="href">"href"</xref> property of a Link
                    Description Object.
                </t>
                <t>
                    Per <xref target="RFC6570">section 1.1 of RFC 6570</xref>, URI Templates
                    are resolved to URI References before resolving references against
                    a base URI.
                </t>
                <figure>
                    <preamble>
                        An example of a JSON schema using "base":
                    </preamble>
                    <artwork>
<![CDATA[
{
    "base": "/object/{id}",
    "links": [
        {
            "rel": "self",
            "href": ""
        },
        {
            "rel": "next",
            "href": "{nextId}"
        }
    ]
}
]]>
                    </artwork>
                </figure>
                <figure>
                    <preamble>
                        An example of a JSON instance using this schema to produce rel="self" and
                        rel="next" links:
                    </preamble>
                    <artwork>
<![CDATA[
{
    "id": 41,
    "nextId": 42
}
]]>
                    </artwork>
                </figure>
                <t>
                    If the document URI is &lt;http://example.com/?id=41&gt;, then the new URI base
                    becomes &lt;http://example.com/object/41&gt;
                </t>
                <t>
                    Resolving the two Link Description Objects against this URI base creates two
                    links exactly equivalent to these absolute-form HTTP Link headers:
                    <list style="symbols">
                        <t>Link: &lt;http://example.com/object/41&gt;;rel=self</t>
                        <t>Link: &lt;http://example.com/object/42&gt;;rel=next</t>
                    </list>
                </t>
            </section>

            <section title="links">
                <t>
                    The "links" property of schemas is used to associate Link Description Objects
                    with instances.  The value of this property MUST be an array, and the items in
                    the array must be Link Description Objects, as defined below.
                </t>

                <figure>
                    <preamble>
                        An example schema using the "links" keyword could be:
                    </preamble>
                    <artwork>
<![CDATA[{
    "title": "Schema defining links",
    "links": [
        {
            "rel": "self",
            "href": "{id}"
        },
        {
            "rel": "parent",
            "href": "{parent}"
        }
    ]
}]]>
                    </artwork>
                </figure>
            </section>

        </section>

        <section title="Link Description Object">
            <t>
                A Link Description Object (LDO) is used to describe a single link relation from the
                instance to another resource.
                A Link Description Object must be an object.
            </t>

            <t>
                The link description format can be used without JSON Schema, and use of this format
                can be declared by referencing the normative link description schema as the schema
                for the data structure that uses the links.
                The URI of the normative link description schema is:
                <eref target="http://json-schema.org/draft-06/links">http://json-schema.org/draft-06/links</eref>
                (draft-06 version).
            </t>

            <section title="Links, operations, and data">
                <t>
                    <cref>
                        Note that while the current draft does not provide a way to explicity
                        indicate HTTP method support, some way of providing a non-authoritative
                        hint may be added in a future draft (see issue #73 in the GitHub repository).
                    </cref>
                </t>
                <t>
                    An operation is a specific use of a link described by an LDO, after any
                    template variables have been resolved.
                </t>
                <t>
                    There are several ways that a client can use data with a link:
                    <list>
                        <t> URI Template variables resolved from server-supplied instance data </t>
                        <t> URI Template variables resolved from user agent data </t>
                        <t> Replacing or modifying the target resource's representation </t>
                        <t> Submitting data for processing, where the data has no
                            inherent relation to the target resource's representation</t>
                    </list>
                    The three ways to use client-supplied data are each addressed by a separate
                    schema keyword within the link description object.  When performing operations,
                    clients SHOULD ignore schemas that are not relevant to their semantics.
                </t>
                <t>
                    Link Description Objects do not directly indicate what operations, such
                    as HTTP methods, are supported by the target resource.  Instead, operations
                    should be inferred primarily from link <xref target="rel">relation types</xref>
                    and URI schemes.  Note, however, that a resource may always decline an operation
                    at runtime, for instance due to application state that controls the operation's
                    availability.
                </t>
                <section title="Resolving templated URIs">
                    <t>
                        URI Template variables in <xref target="href">"href"</xref> resolve from
                        server-supplied instance data by default.  This data is drawn from the
                        sub-instance that validated against the schema containing the LDO.
                    </t>
                    <t>
                        <xref target="hrefPointers">"hrefPointers"</xref> allows adjusting
                        the location from which instance data is resolved on a per-variable
                        basis.
                    </t>
                    <t>
                        <xref target="hrefSchema">"hrefSchema"</xref> allows a link to specify
                        a schema for resolving template variables from client-supplied data.
                        Regular JSON Schema validation features can be used to require resolution
                        from user agent data, forbid it, or allow user agent data while falling back
                        to server-supplied instance data if no user agent data is provided.
                    </t>
                    <t>
                        To implement the common pattern of resolving a templated path component
                        with server-supplied instance data while accepting user agent data to build
                        a query string:
                        <list style="symbols">
                            <t>
                                set the "hrefSchema" subschemas for the path template variables
                                to false, to disallow user agent input
                            </t>
                            <t>
                                give the query string template variables names that do not appear
                                in the instance, to prevent resolving them from the instance
                            </t>
                        </list>
                        See the "hrefSchema" section for an example of this approach.
                    </t>
                    <t>
                        To implement the equivalent of an input form pre-populated with
                        pre-existing instance data:
                        <list style="symbols">
                            <t>
                                ensure that each variable in the form resolves from the appropriate
                                field in the instance, which provides the initial value that will
                                continue to be used if the user agent takes no action to change it
                            </t>
                            <t> provide a validation schema for each of those fields in
                                "hrefSchema", to describe what user agent input may be allowed
                                to replace it
                            </t>
                        </list>
                        This can be done with variables in any component of the URI template
                        (path, query string, etc.)  While the word "form" is used here,
                        JSON Hyper-Schema does not constraint the nature of this interaction, which
                        may or may not involve rendering an interactive form.
                    </t>
                </section>
                <section title="Manipulating the target resource representation">
                    <t>
                        In JSON Hyper-Schema, <xref target="targetSchema">"targetSchema"</xref>
                        supplies a non-authoritative description of the target resource's
                        representation. A client can use "targetSchema" to structure input for
                        replacing or modifying the representation.  Alternatively, if "targetSchema"
                        is absent or if the client prefers to only use authoritative information, it
                        can interact with the target resource to confirm or discover its
                        representation structure.
                    </t>
                    <t>
                        "targetSchema" is not intended to describe link operation responses,
                        except when the response semantics indicate that it is a representation
                        of the target resource.  In all cases, the schema indicated by the response
                        itself is authoritative.  See the
                        <xref target="targetHTTP" /> for guidance
                        specific to each HTTP method when using "targetSchema" with HTTP URIs.
                    </t>
                </section>
                <section title="Submitting data for processing">
                    <t>
                        The <xref target="submissionSchema">"submissionSchema"</xref> and
                        <xref target="submissionEncType">"submissionEncType"</xref> keywords
                        describe the domain of the processing function implemented by the target
                        resource. Otherwise, as noted above, the submission schema and encoding are
                        ignored for operations to which they are not relevant.
                    </t>
                </section>
            </section>

            <!-- Possibly include a short section on motivations, including triples, resources, and progressive disclosure -->

            <section title="href" anchor="href">
                <t>
                    The value of the "href" link description property is a template used to
                    determine the target URI of the related resource.
                    The value of the instance property MUST be resolved as a
                    <xref target="RFC3986">URI-reference</xref> against the base URI of the
                    instance.
                </t>
                <t>
                    This property is REQUIRED.
                </t>

                <section title="URI Templating">
                    <t>
                        <cref>
                            The pre-processing rules present in earlier drafts have been removed due
                            to their complexity and inability to address all limitations with URI
                            templating.
                            This section is subject to significant change in upcoming drafts to
                            replace the old pre-processing with a comprehensive solution.
                        </cref>
                    </t>
                    <t>
                        The value of "href" is to be used as a URI Template, as defined in
                        <xref target="RFC6570">RFC 6570</xref>.
                        However, some special considerations apply:
                    </t>

                    <section title="Values for substitution">
                        <t>
                            The URI Template is filled out using data from some combination of an
                            external source and the instance.
                            Where either instance data or user agent data may be used, this section
                            will refer simply to "data" or to a "value".
                            When the source is important, it is specified explicitly.

                            To allow the use of any object property (including the empty string) or
                            array index, the following rules are defined:
                        </t>

                        <t>
                            For a given variable name in the URI Template, the value to use is
                            determined as follows:
                            <list>
                                <t>
                                    If the data is an array, and the variable name is a
                                    representation of a non-negative integer, then the value at the
                                    corresponding array index MUST be used (if it exists).
                                </t>
                                <t>
                                    Otherwise, the variable name should be percent-decoded, and the
                                    corresponding object property MUST be used (if it exists).
                                </t>
                            </list>
                        </t>

                        <t>
                            If <xref target="hrefSchema">"hrefSchema"</xref> is present and
                            user agent data is provided, the data MUST be a valid instance according
                            to the value of "hrefSchema".
                            Template variables, after the process listed above, MUST first
                            be resolved from the user agent data instance.  Any variables left
                            unresolved MUST be resolved from the resource instance data.
                        </t>

                        <section title="Converting to strings">
                            <t>
                                When any value referenced by the URI template is null, a boolean or
                                a number, then it should first be converted into a string as
                                follows:
                                <list>
                                    <t>
                                        null values SHOULD be replaced by the text "null"
                                    </t>
                                    <t>
                                        boolean values SHOULD be replaced by their lower-case
                                        equivalents: "true" or "false"
                                    </t>
                                    <t>
                                        numbers SHOULD be replaced with their original JSON
                                        representation.
                                    </t>
                                </list>
                            </t>
                            <t>
                                In some software environments the original JSON representation of a
                                number will not be available (there is no way to tell the difference
                                between 1.0 and 1), so any reasonable representation should be used.
                                Schema and API authors should bear this in mind, and use other types
                                (such as string or boolean) if the exact representation is
                                important.
                            </t>
                        </section>
                    </section>

                    <section title="Missing values" anchor="missingValues">
                        <t>
                            Sometimes, the appropriate values will not be available.
                            For example, the template might specify the use of object properties,
                            but no such data was provided (or "hrefSchema" is not present), and the
                            instance is an array or a string.
                        </t>

                        <t>
                            If any of the values required for the template are neither present in
                            the user agent data (if relevant) nor the JSON instance, then substitute
                            values MAY be provided from another source (such as default values).
                            Otherwise, the link definition SHOULD be considered not to apply to the
                            instance.
                        </t>
                    </section>
                </section>

            </section>

            <section title="hrefPointers" anchor="hrefPointers">
                <t>
                    The value of the "hrefPointers" link description property MUST be
                    an object.  Each property value in the object MUST be a valid
                    <xref target="RFC6901">JSON Pointer</xref>, or a valid
                    <xref target="I-D.luff-relative-json-pointer">Relative JSON Pointer</xref>
                    which is evaluated relative to the position in the instance from which
                    <xref target="href">"href"</xref> template variable resolution would
                    normally begin.
                </t>
                <t>
                    For each property name in the object that matches a variable name in the
                    "href" URI Template, the value of that property adjusts the starting position
                    of variable resolution for that variable.  Properties which do not match
                    "href" template variable names MUST be ignored.
                </t>
                <figure>
                    <preamble>
                        Recall that a Relative JSON Pointer begins with a number indicating
                        how many levels up to move before applying the remainder of the pointer,
                        if any, in the same manner as a regular JSON Pointer.  Consider the
                        following schema for n-ary tree nodes, where a node is identified by
                        its own id as well as the tree's root node id, and links are given for
                        the IANA-registered "self" and "up" link relation types.
                    </preamble>
                    <artwork>
<![CDATA[{
    "type": "object",
    "required": ["id"],
    "properties": {
        "id": {"type": "integer", "minimum": 0},
        "children": {"type": "array", "items": {"$ref": "#"}}
    },
    "links": [
        {
            "rel": "self",
            "href": "/trees/{rootId}/nodes/{id}",
            "hrefPointers": {
                "rootId": "/id"
            }
        },
        {
            "rel": "up",
            "href": "/trees/{rootId}/nodes/{parentId}",
            "hrefPointers": {
                "rootId": "/id",
                "parentId": "2/id"
            }
        }
    ]
}]]>
                    </artwork>
                </figure>
                <t>
                    In "self" link, the context node's id resolves with the standard process and
                    therefore does not appear in "hrefPointers".  In both "self" and "up" links,
                    the root id is located using an absolute JSON Pointer. Finally, in "up" link,
                    the parent node uses a Relative JSON Pointer, going up two levels (one level up
                    is the array of children, two levels up is the whole parent node), and then
                    looking at the "id" field from that point.
                </t>
                <figure>
                    <preamble>
                        Given the following instance:
                    </preamble>
                    <artwork>
<![CDATA[{
  "id": 0,
  "children": [ {
    "id": 1,
    "children": [ {
      "id": 2,
      "children": [ {
        "id": 3
      } ]
    } ]
  } ]
}]]>
                    </artwork>
                </figure>
                <t>
                    For each node (as identified by JSON Pointers), we get these "self" links:
                    <list style="hanging">
                        <t hangText='"" (the root node)'>/trees/0/nodes/0</t>
                        <t hangText='"/children/0"'>/trees/0/nodes/1</t>
                        <t hangText='"/children/0/children/0"'>/trees/0/nodes/2</t>
                        <t hangText='"/children/0/children/0/children/0"'>/trees/0/nodes/3</t>
                    </list>
                </t>
                <t>
                    and these "up" links:
                    <list style="hanging">
                        <t hangText='"/children/0"'>/trees/0/nodes/0</t>
                        <t hangText='"/children/0/children/0"'>/trees/0/nodes/1</t>
                        <t hangText='"/children/0/children/0/children/0"'>/trees/0/nodes/2</t>
                    </list>
                </t>
                <t>
                    For the root node, the relative pointer for the parent doesn't point
                    to anything.  As noted under
                    <xref target="missingValues">missing values</xref>, such a link should
                    simply be ignored.
                    <cref>
                        GitHub issue #49 tracks the question of distinguishing this situation
                        of a missing required variable (common in path components) from
                        missing optional variables (common in query string parameters).
                    </cref>
                </t>
            </section>

            <section title="hrefSchema" anchor="hrefSchema">
                <t>
                    The value of the "hrefSchema" link description property MUST be
                    a valid JSON Schema.  This schema is used to validate user input
                    or other user agent data for filling out the URI Template in
                    <xref target="href">"href"</xref>, as described in that section.
                </t>
                <t>
                    Omitting "hrefSchema" or setting the entire schema to "false" prevents
                    any user agent data from being accepted.
                </t>
                <t>
                    Implementations MUST NOT attempt to validate values resolved from
                    resource instance data with "hrefSchema".  This allows for different
                    validation rules for user agent data, such as supporting spelled-out
                    months for date-time input but using the standard date-time
                    format for storage.
                </t>
                <figure>
                    <preamble>
                        For example, this defines a schema for each of the query string
                        parameters in the URI template:
                    </preamble>
                    <artwork>
<![CDATA[{
    "href": "/foos{?condition,count,query}",
    "hrefSchema": {
        "properties": {
            "condition": {
                "type": "boolean",
                "default": true
            },
            "count": {
                "type": "integer",
                "minimum": 0,
                "default": 0
            },
            "query": {
                "type": "string"
            }
        }
    }
}]]>
                    </artwork>
                </figure>
                <figure>
                    <preamble>
                        In this example, the schema for "extra" is given as a reference
                        to keep the user agent data validation constraints identical to the
                        instance validation constraints for the corresponding property,
                        while "id" is given a false schema to prevent user agent data for
                        that variable.
                    </preamble>
                    <artwork>
<![CDATA[{
    "definitions": {
        "extra": {
            "type": "string",
            "maxLength": 32
        }
    },
    "type": "object",
    "properties": {
        "id": {
            "type": "integer",
            "minimum": 1,
            "readOnly": true
        },
        "extra": {"$ref": "#/definitions/extra"}
    },
    "links": [{
        "rel": "self",
        "href": "/things/{id}{?extra}",
        "hrefSchema": {
            "properties": {
                "id": false,
                "extra": {"$ref": "#/definitions/extra"}
            }
        }
    }]
}]]>
                    </artwork>
                </figure>
                <t>
                    <cref>
                        The above example simulates the behavior handled in earlier drafts
                        with a "method" of "get" by using the new "hrefSchema" keyword.
                    </cref>
                </t>
            </section>

            <section title="rel" anchor="rel">
                <t>
                    The value of the "rel" property indicates the name of the relation to the target
                    resource. The value MUST be a registered link relation from the
                    <xref target="RFC5988">IANA Link Relation Type Registry established in RFC 5988</xref>,
                    or a normalized URI following the <xref target="RFC3986">URI production of RFC 3986</xref>.
                    This property is required.
                </t>

                <t>
                    As defined by RFC 5988, a link connects a context resource
                    to a target resource, where the nature of the connection
                    is described by the link relation type.  The context
                    resource is the instance to which the schema (or sub-schema)
                    applies, rather than any larger document in which the
                    instance may have been found.  The context may be changed
                    with the <xref target="anchor">"anchor"</xref> or
                    <xref target="anchorPointer">"anchorPointer"</xref> properties.
                </t>

                <t>
                    Depending on the media type of the instance, it may or may
                    not be possible to assign a URI to the exact default context
                    resource.  In particular, application/json does not define
                    URI fragment resolution semantics, so properties or array
                    elements within a plain JSON document cannot be identified
                    by a URI.
                </t>

                <t>
                    Relationship definitions are not normally media type
                    dependent, and users are encouraged to utilize the most
                    suitable existing accepted relation definitions.
                </t>

                <t>
                    When no registered relation (aside from "related") applies, users are
                    encouraged to mint their own extension relation types, as described in
                    <xref target="RFC5988">section 4.2 of RFC 5988</xref>.  The simplest
                    approaches for choosing link relation type URIs are to either use
                    a URI scheme that is already in use to identify the system's primary
                    resources, or to use a human-readable, non-dereferenceable URI scheme
                    such as <xref target="RFC4151">"tag", defined by RFC 4151</xref>.
                    Extension relation type URIs need not be dereferenceable, even when
                    using a scheme that allows it.
                </t>
                <figure>
                    <preamble>
                        As an example of registered relation types, if a hyper-schema is defined:
                    </preamble>
                    <artwork>
<![CDATA[{
    "type": "array",
    "items": {
        "links": [{
            "rel": "item",
            "href": "{id}"
        }, {
            "rel": "up",
            "href": "{upId}"
        }]
    }
}]]>
                    </artwork>
                </figure>

                <figure>
                    <preamble>
                        And if a collection of instance resources were retrieved with JSON
                        representation:
                    </preamble>
                    <artwork>
<![CDATA[GET /Resource/

[{
    "id": "thing",
    "upId": "parent"
}, {
    "id": "thing2",
    "upId": "parent"
}]]]>
                    </artwork>
                    <postamble>
                        This would indicate that for the first item in the collection, its URI as
                        its own resource would resolve to "/Resource/thing" and the first item's
                        "up" relation SHOULD be resolved to the resource at "/Resource/parent".
                    </postamble>
                </figure>

                <t>
                    Note that these relationship values are case-insensitive, consistent with their
                    use in HTML and the <xref target="RFC5988">HTTP Link header</xref>.
                </t>

                <section title="Security Considerations for &quot;self&quot; links">
                    <t>
                        When link relation of "self" is used to denote a full representation of an
                        object, the user agent SHOULD NOT consider the representation to be the
                        authoritative representation of the resource denoted by the target URI if
                        the target URI is not equivalent to or a sub-path of the URI used to request
                        the resource representation which contains the target URI with the "self"
                        link.

                        <figure>
                            <preamble>
                                For example, if a hyper-schema was defined:
                            </preamble>
                            <artwork>
<![CDATA[{
    "links": [{
        "rel": "self",
        "href": "{id}"
    }]
}]]>
                            </artwork>
                        </figure>

                        <figure>
                            <preamble>
                                And a resource was requested from somesite.com:
                            </preamble>
                            <artwork>
<![CDATA[
GET /foo/
]]>
                            </artwork>
                        </figure>

                        <figure>
                            <preamble>
                                With a response of (with newlines and whitespace added):
                            </preamble>
                            <artwork>
<![CDATA[Content-Type: application/json; profile="http://example.com/alpha"

[{
    "id": "bar",
    "name": "This representation can be safely treated
             as authoritative "
}, {
    "id": "/baz",
    "name": "This representation should not be treated as
             authoritative the user agent should make request the
             resource from '/baz' to ensure it has the authoritative
             representation"
}, {
    "id": "http://othersite.com/something",
    "name": "This representation
             should also not be treated as authoritative and the
             target resource representation should be retrieved
             for the authoritative representation"
}]]]>
                            </artwork>
                        </figure>
                    </t>
                </section>
            </section>

            <section title="anchor" anchor="anchor">
                <t>
                    This property sets the context URI of the link.
                    The value of the property MUST be resolved as a
                    <xref target="RFC3986">URI-reference</xref> against
                    the base URI of the instance.
                </t>
            </section>

            <section title="anchorPointer" anchor="anchorPointer">
                <t>
                    This property changes the point within the instance that is considered
                    to be the context resource of the link.  The value of the property MUST be a
                    valid <xref target="RFC6901">JSON Pointer</xref>, or a valid 
                    <xref target="I-D.luff-relative-json-pointer">Relative JSON Pointer</xref>
                    which is evaluated relative to the position in the instance from which
                    <xref target="href">"href"</xref> template variable resolution would
                    normally begin.
                </t>
                <t>
                    While an alternate context with a known URI is best set with the
                    <xref target="anchor">"anchor"</xref> keyword, the lack of a fragment identifier
                    syntax for application/json means that it is usually not possible to
                    change the context within a JSON instance using a URI.
                </t>
                <t>
                    Even in "+json" media types that define JSON Pointer as a fragment identifier
                    syntax, if the default context is nested within an array, it is not possible to
                    obtain the index of the default context's position in that array in order
                    to construct a pointer to another property in that same nested JSON object.
                </t>

                <figure>
                    <preamble>
                        For example, given this hyper-schema:
                    </preamble>
                    <artwork>
<![CDATA[{
    "type": "object",
    "properties": {
        "theThing": {
            "type": "object",
            "properties": {
                "name": {"type": "string"}
            }
        },
        "examples": {
            "title": "The collection of example for the thing",
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "id": {"type": "integer"}
                },
                "links": [{
                    "rel": "item",
                    "href": "/examples/{id}",
                    "anchorPointer": "1"
                }]
            }
        }
    }
}]]>
                    </artwork>
                    <postamble>
                        The "item" relation indicates that each array entry can be used to construct
                        a link from the collection embedded in this instance to a resource for that
                        specific item.  The default context of this link is the individual array
                        element.  But the context of an "item" relation should be the collection,
                        which is the entire "examples" array.  The Relative JSON Pointer of "1"
                        accomplishes this as follows:
                    </postamble>
                </figure>
                <figure>
                    <preamble>
                        Given this instance of media type application/json:
                    </preamble>
                    <artwork>
<![CDATA[{
    "theThing": {"name": "An actual thing"},
    "examples": [{"id": 1234}, {"id": 5678}]
}]]>
                    </artwork>
                    <postamble>
                        The default context for the link to "/examples/1234" is the first
                        array entry, and for the link to "/examples/5678" it is the second array
                        entry.  But "anchorPointer" moves this up one instance level (the "1"
                        Relative JSON Pointer) to be the array containing each entry.
                    </postamble>
                </figure>
                <t>
                    If both "anchor" and "anchorPointer" are defined, and do not resolve to
                    the same link context, the resulting behavior is undefined.
                </t>
            </section>

            <section title="title">
                <t>
                    This property defines a title for the link.
                    The value MUST be a string.
                </t>

                <t>
                    User agents MAY use this title when presenting the link to the user.
                </t>
            </section>

            <section title="description">
                <t>
                    This property provides additional information beyond what
                    is present in the title.  The value MUST be a string.
                    While a title is preferably short, a description can be
                    used to go into more detail about the purpose and usage
                    of the link.
                </t>

                <t>
                    User agents MAY use this description when presenting
                    the link to the user.
                </t>
            </section>

            <section title="targetSchema" anchor="targetSchema">
                <t>
                    This property provides a schema that is expected to describe
                    the link target's representation.  Depending on the protocol,
                    the schema may or may not describe the response to any particular
                    request sent to the link.  This property is advisory only.
                </t>
                <section title="&quot;targetSchema&quot; and HTTP" anchor="targetHTTP">
                    <t>
                        The relationship between a resource's representation and HTTP requests and
                        responses is determined by <xref target="RFC7231">RFC 7231, section 4.3.1 -
                            "GET", section 4.3.4 "PUT", and section 3.1.4.2,
                            "Content-Location"</xref>. In particular, "targetSchema" suggests what a
                        client can expect for the response to an HTTP GET or any response for which
                        the "Content-Location" header is equal to the request URI, and what a client
                        should send if it replaces the resource in an HTTP PUT request. Per <xref
                            target="RFC5789">RFC 5789</xref>, the request structure for an HTTP
                        PATCH is determined by the combination of "targetSchema" and the request
                        media type.
                    </t>
                </section>
                <section title="Security Considerations for &quot;targetSchema&quot;">
                    <t>
                        This property has similar security concerns to that of "mediaType".
                        Clients MUST NOT use the value of this property to aid in the interpretation
                        of the data received in response to following the link, as this leaves
                        "safe" data open to re-interpretation.
                    </t>
                    <t>
                        <figure>
                            <preamble>
                                For example, suppose two programmers are having a discussion about
                                web security using a text-only message board.
                                Here is some data from that conversation, with a URI of:
                                http://forum.example.com/topics/152/comments/13
                            </preamble>
                            <artwork>
<![CDATA[{
    "topicId": 152,
    "commentId": 13,
    "from": {
        "name": "Jane",
        "id": 5
    },
    "to": {
        "name": "Jason",
        "id": 8
    },
    "message": "It's easy, just add some HTML like
         this: <script>doSomethingEvil()</script>"
}]]>
                            </artwork>
                            <postamble>
                                The message string was split over two lines for readability.
                            </postamble>
                        </figure>
                    </t>
                    <t>
                        A third party might then provide the following Link Description Object at
                        another location:
                        <figure>
                            <artwork>
<![CDATA[{
    "rel": "evil-attack",
    "href": "http://forum.example.com/topics/152/comments/13",
    "targetSchema": {
        "properties": {
            "message": {
                "description": "Re-interpret `message` as HTML",
                "contentMediaType": "text/html"
            }
        }
    }
}]]>
                            </artwork>
                            <postamble>
                                If the client used this "targetSchema" value when interpreting the
                                above data, then it might display the contents of "message" as HTML.
                                At this point, the JavaScript embedded in the message might be
                                executed (in the context of the "forum.example.com" domain).
                            </postamble>
                        </figure>
                    </t>
                </section>
            </section>

            <section title="targetHints" anchor="targetHints">
                <t>
                    <cref>
                        This section attempts to strike a balance between comprehensiveness
                        and flexibility by deferring most of its structure to the protocol
                        indicated by the URI scheme.  Note that a resource can be identified
                        by a URI with a dereferenceable scheme, yet not be accessible over
                        that protocol.  While currently very loose, this section is expected
                        to become more well-defined based on draft feedback, and may change
                        significantly in future drafts.
                    </cref>
                </t>
                <t>
                    The value of this property is advisory only.  It represents information that
                    is expected to be discoverable through interacting with the target resource,
                    typically in the form of protocol-specific control information or meta-data
                    such as headers returned in response to an HTTP HEAD or OPTIONS request.
                    The protocol is determined by the "href" URI scheme, although note that
                    resources are not guaranteed to be accessible over such a protocol.
                </t>
                <t>
                    The value of this property SHOULD be an object.  The keys to this object
                    SHOULD be lower-cased forms of the control data field names.  Each value
                    SHOULD be an array, in order to uniformly handle multi-valued fields.
                    Multiple values MUST be presented as an array, and not as a single string.
                </t>
                <t>
                    Protocols with control information not suitable for representation as
                    a JSON object MAY be represented by another data type, such as an array.
                </t>
                <t>
                    Values that cannot be understood as part of the indicated protocol MUST
                    be ignored by a JSON Hyper-Schema implementation.  Applications MAY make
                    use of such values, but MUST NOT assume interoperability with other
                    implementations.
                </t>
                <t>
                    Implementations MUST NOT assume that all discoverable information is
                    accounted for in this object.  Clients MUST properly handle run-time responses
                    that contradict this property's values.
                </t>
                <t>
                    Clients MUST NOT assume that an implementation will automatically take any
                    action based on the value of this property.
                </t>
                <section title='"targetHints" for HTTP'>
                    <t>
                        <cref>It would be good to also include a section with CoAP examples.</cref>
                    </t>
                    <t>
                        JSON serializations of HTTP response header information SHOULD follow the
                        guidelines established by the work in progress
                        <xref target="I-D.reschke-http-jfv">"A JSON Encoding for HTTP Header Field Values"</xref>.
                        Approaches shown in that document's examples SHOULD be applied to other
                        similarly structured headers wherever possible.
                    </t>
                    <t>
                        No distinction is made between headers that may appear in responses to
                        different methods, such as HEAD vs OPTIONS.
                    </t>
                    <figure>
                        <preamble>
                            This examples shows several hints that are useful for clients
                            when determining what requests to make and how to make them.
                        </preamble>
                        <artwork>
<![CDATA[{
    "targetHints": {
        "allow": ["GET", "PUT"],
        "accept-patch": ["application/merge-patch+json"],
        "accept-ranges": ["none"]
    }
}]]>
                        </artwork>
                    </figure>
                </section>
            </section>

            <section title="mediaType">
                <t>
                    The value of this property is advisory only, and represents the media type
                    <xref target="RFC2046">RFC 2046</xref>, that is expected to be returned when
                    fetching this resource.
                    This property value MAY be a media range instead, using the same pattern defined
                    in <xref target="RFC7231">RFC 7231, section 5.3.2 - HTTP "Accept" header</xref>.
                </t>

                <t>
                    This property is analogous to the "type" property of &lt;a&gt; elements in HTML
                    (advisory content type), or the "type" parameter in the
                    <xref target="RFC5988">HTTP Link header</xref>.
                    User agents MAY use this information to inform the interface they present to the
                    user before the link is followed, but this information MUST NOT use this
                    information in the interpretation of the resulting data.
                    When deciding how to interpret data obtained through following this link, the
                    behaviour of user agents MUST be identical regardless of the value of the this
                    property.
                </t>

                <t>
                    If this property's value is specified, and the link's target is to be obtained
                    using any protocol that supports the HTTP/1.1 "Accept" header
                    <xref target="RFC7231">RFC 7231, section 5.3.2</xref>, then user agents MAY use
                    the value of this property to aid in the assembly of that header when making the
                    request to the server.
                </t>

                <t>
                    If this property's value is not specified, then the value should be taken to be
                    "application/json".  Hyper-Schema authors SHOULD NOT use a protocol-specific
                    value in <xref target="targetHints">"targetHints"</xref> for this purpose.
                </t>

                <figure>
                    <preamble>
                        For example, if a schema is defined:
                    </preamble>
                    <artwork>
<![CDATA[
{
    "links": [{
        "rel": "self",
        "href": "/{id}/json"
    }, {
        "rel": "alternate",
        "href": "/{id}/html",
        "mediaType": "text/html"
    }, {
        "rel": "alternate",
        "href": "/{id}/rss",
        "mediaType": "application/rss+xml"
    }, {
        "rel": "icon",
        "href": "{id}/icon",
        "mediaType": "image/*"
    }]
}
]]>
                    </artwork>
                    <postamble>
                        A suitable instance described by this schema would have four links defined.
                        The link with a "rel" value of "self" would have an expected MIME type of
                        "application/json" (the default).
                        The two links with a "rel" value of "alternate" specify the locations of
                        HTML and RSS versions of the current item.
                        The link with a "rel" value of "icon" links to an image, but does not
                        specify the exact format.
                    </postamble>
                </figure>

                <t>
                    A visual user agent displaying the item from the above example might present a
                    button representing an RSS feed, which when pressed passes the target URI
                    (calculated "href" value) to an view more suited to displaying it, such as a
                    news feed aggregator tab.
                </t>

                <t>
                    Note that presenting the link in the above manner, or passing the URI to a news
                    feed aggregator view does not constitute interpretation of the data, but an
                    interpretation of the link.
                    The interpretation of the data itself is performed by the news feed aggregator,
                    which SHOULD reject any data that would not have also been interpreted as a news
                    feed, had it been displayed in the main view.
                </t>

                <section title="Security concerns for &quot;mediaType&quot;">
                    <t>
                        The "mediaType" property in link definitions defines the expected format of
                        the link's target.
                        However, this is advisory only, and MUST NOT be considered authoritative.
                    </t>

                    <t>
                        When choosing how to interpret data, the type information provided by the
                        server (or inferred from the filename, or any other usual method) MUST be
                        the only consideration, and the "mediaType" property of the link MUST NOT be
                        used.
                        User agents MAY use this information to determine how they represent the
                        link or where to display it (for example hover-text, opening in a new tab).
                        If user agents decide to pass the link to an external program, they SHOULD
                        first verify that the data is of a type that would normally be passed to
                        that external program.
                    </t>

                    <t>
                        This is to guard against re-interpretation of "safe" data, similar to the
                        precautions for "targetSchema".
                    </t>
                </section>
            </section>

            <section title="headerSchema" anchor="headerSchema">
                <t>
                    <cref>
                        As with "targetHints", this keyword is somewhat under-specified
                        to encourage experimentation and feedback as we try to balance
                        flexibility and clarity.
                    </cref>
                </t>
                <t>
                    If present, this property is a schema for protocol-specific request
                    headers or analogous control and meta-data.  The value of this
                    object MUST be a valid JSON Schema.
                    The protocol is determined by the "href" URI scheme, although note that
                    resources are not guaranteed to be accessible over such a protocol.
                    The schema is advisory only; the target resource's behavior is not
                    constrained by its presence.
                </t>
                <t>
                    The purpose of this keyword is to advertise target resource interaction
                    features, and indicate to clients what headers and header values are
                    likely to be useful.  Clients MAY use the schema to validate relevant
                    headers, but MUST NOT assume that missing headers or values are forbidden
                    from use.  While schema authors MAY set "additionalProperties" to
                    false, this is NOT RECOMMENDED and MUST NOT prevent clients or user agents
                    from supplying additional headers when requests are made.
                </t>
                <t>
                    The exact mapping of the JSON data model into the headers is
                    protocol-dependent.  However, in most cases this schema SHOULD
                    specify a type of "object", and the property names SHOULD be
                    lower-cased forms of the control data field names.
                </t>
                <t>
                    "headerSchema" is applicable to any request method or command that the
                    protocol supports.  When generating a request, clients SHOULD ignore
                    schemas for headers that are not relevant to that request.
                </t>
                <section title='"headerSchema" for HTTP'>
                    <t>
                        Schemas SHOULD be written to describe JSON serializations that
                        follow guidelines established by the work in progress
                        <xref target="I-D.reschke-http-jfv">"A JSON Encoding for HTTP Header Field Values"</xref>
                        Approaches shown in that document's examples SHOULD be applied to
                        other similarly structured headers wherever possible.
                    </t>
                    <t>
                        The "Prefer" header defined in <xref target="RFC7240">RFC 7240</xref>
                        is a good candidate for description in "headerSchema".  It defines
                        several standard values and allows for extension values.
                    </t>
                    <figure>
                        <preamble>
                            This schema indicates that the target understands the
                            "respond-async" preference, the "wait" preference which
                            takes a number of seconds to wait, as well as "minimal" and
                            "representation" for the "return" preference.
                        </preamble>
                        <artwork>
<![CDATA[{
    "type": "object",
    "properties": {
        "prefer": {
            "type": "array",
            "items": {
                "oneOf": [
                    {"const": "respond-async"},
                    {
                        "type": "object",
                        "minProperties": 1,
                        "maxProperties": 1,
                        "properties": {
                            {
                                "return": {
                                    "enum": [
                                        "representation",
                                        "minimal"
                                    ]
                                },
                                "wait": {
                                    "type": "integer",
                                    "minimum": 1
                                }
                            }
                        }
                    }
                ]
            },
            "uniqueItems": true
        }
    }
}]]>
                        </artwork>
                        <postamble>
                            Each name/value preference pair is a single value of the
                            header, so each object in the list can only have one such
                            pair.  Simplifying the "response-async" value to a single string
                            is based on the "Accept-Encoding" example in
                            <xref target="I-D.reschke-http-jfv">appendix A.4 of the JSON encoding draft</xref>.
                        </postamble>
                    </figure>
                    <t>
                        The Prefer header also stretches the limits of existing recommendations
                        for serializing HTTP headers in JSON.  It is possible for both the
                        single string and name/value pair preferences to take additional
                        name/value parameters.  While a single-string preference can accomodate
                        such parameters following the "Accept-Encoding" example, there is
                        no example to date of a name/value pair with parameters.
                        <cref>
                            We hope to get feedback from hyper-schema authors on what
                            practical concerns arise, and from there decide how best to
                            handle them.  The specification for this keyword is expected to
                            become more well-defined in future drafts.
                        </cref>
                    </t>
                </section>
            </section>

            <section title="submissionEncType" anchor="submissionEncType">
                <t>
                    If present, this property indicates the media type format the
                    client should use for the request payload described by
                    <xref target="submissionSchema">"submissionSchema"</xref>.
                </t>
                <t>
                    Omitting this keyword has the same behavior as a value of application/json.
                </t>
                <t>
                    Note that "submissionEncType" and "submissionSchema"
                    are not restricted to HTTP URIs.

                    <figure>
                        <preamble>
                            For example, this link indicates that if you want to
                            send an email to the author of the context resource,
                            your client needs to ask for both a plain text
                            and an HTML representation.
                        </preamble>
                        <artwork>
<![CDATA[{
    "links": [{
        "submissionEncType": "multipart/alternative; boundary=ab12",
        "rel": "author",
        "href": "mailto:someone@example.com{?subject}",
        "hrefSchema": {
            "type": "object",
            "properties": {
                "subject": { "type": "string" }
            },
            "required": ["subject"]
        },
        "submissionSchema": {
            "type": "array",
            "items": [
                {
                    "type": "string",
                    "contentMediaType": "text/plain; charset=utf8"
                },
                {
                    "type": "string",
                    "contentMediaType": "text/html"
                }
            ],
            "minItems": 2
        }
    }]
}]]>
                        </artwork>
                    </figure>
                </t>
            </section>

            <section title="submissionSchema" anchor="submissionSchema">
                <t>
                    This property contains a schema which defines the acceptable structure
                    of the document to be encoded according to the "submissionEncType" property
                    and sent to the target resource for processing.  This can be viewed as
                    describing the domain of the processing function implemented by the
                    target resource.
                </t>

                <t>
                    This is a separate concept from the
                    <xref target="targetSchema">"targetSchema"</xref> property, which is describing
                    the target information resource (including for replacing the contents of the
                    resource in a PUT request), unlike "submissionSchema" which describes the
                    user-submitted request data to be evaluated by the resource. "submissionSchema"
                    is intended for use with requests that have payloads that are not defined in
                    terms of the target representation.
                </t>
                <t>
                    Omitting "submissionSchema" or setting the entire schema to "false" prevents
                    any user agent data from being accepted.
                </t>
            </section>
        </section>

<!--
        <section title="IANA Considerations">
            <t>No considerations</t>
        </section>
-->
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &rfc2119;
            &rfc3986;
            <!--&rfc4287;-->
            &rfc6570;
            &rfc6901;
            &I-D.luff-relative-json-pointer;
            &I-D.reschke-http-jfv;
            <reference anchor="json-schema">
                <front>
                    <title>JSON Schema: A Media Type for Describing JSON Documents</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <date year="2016" month="October"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-wright-json-schema-01" />
            </reference>
            <reference anchor="json-schema-validation">
                <front>
                    <title>JSON Schema Validation: A Vocabulary for Structural Validation of JSON</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <date year="2016" month="October"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-wright-json-schema-validation-01" />
            </reference>
        </references>
        <references title="Informative References">
            &rfc2046;
            <!--&rfc5226;-->
            &rfc4151;
            &rfc5789;
            &rfc5988;
            &rfc7231;
            &rfc7240;
        </references>

        <section title="Acknowledgments">
            <t>
                Thanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.
            </t>
            <t>
                Thanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Ben Hutton,
                Evgeny Poberezkin,
                Brad Bowman,
                Gowry Sankar,
                Donald Pipowitch,
                Dave Finlay,
                and Denis Laxalde
                for their submissions and patches to the document.
            </t>
        </section>

        <section title="Change Log">
            <t>
                <cref>This section to be removed before leaving Internet-Draft status.</cref>
            </t>
            <t>
                <list style="hanging">
                    <t hangText="draft-wright-json-schema-hyperschema-02">
                        <list style="symbols">
                            <t></t>
                        </list>
                    </t>
                    <t hangText="draft-wright-json-schema-hyperschema-01">
                        <list style="symbols">
                            <t>Fixed examples</t>
                            <t>Added "hrefSchema" for user input to "href" URI Templates</t>
                            <t>Removed URI Template pre-processing</t>
                            <t>Clarified how links and data submission work</t>
                            <t>Clarified how validation keywords apply hyper-schema keywords and links</t>
                            <t>Clarified HTTP use with "targetSchema"</t>
                            <t>Renamed "schema" to "submissionSchema"</t>
                            <t>Renamed "encType" to "submissionEncType"</t>
                            <t>Removed "method"</t>
                        </list>
                    </t>
                    <t hangText="draft-wright-json-schema-hyperschema-00">
                        <list style="symbols">
                            <t>"rel" is now optional</t>
                            <t>rel="self" no longer changes URI base</t>
                            <t>Added "base" keyword to change instance URI base</t>
                            <t>Removed "root" link relation</t>
                            <t>Removed "create" link relation</t>
                            <t>Removed "full" link relation</t>
                            <t>Removed "instances" link relation</t>
                            <t>Removed special behavior for "describedBy" link relation</t>
                            <t>Removed "pathStart" keyword</t>
                            <t>Removed "fragmentResolution" keyword</t>
                            <t>Updated references to JSON Pointer, HTML</t>
                            <t>Changed behavior of "method" property to align with hypermedia best current practices</t>
                        </list>
                    </t>
                    <t hangText="draft-luff-json-hyper-schema-01">
                        <list style="symbols">
                            <t>Split from main specification.</t>
                        </list>
                    </t>
                </list>
            </t>
        </section>
    </back>
</rfc>
